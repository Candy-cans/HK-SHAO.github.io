<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>函数绘图（开发中v1.3）</title>
    <style type="text/css">
        #father {
            position: relative;
            margin: 0px auto;
            border: dotted;
        }

        #father #gc {
            position: absolute;
            opacity: 0.8;
            z-index: 2;
        }

        #father #gc2 {
            position: absolute;
            z-index: 1;
        }

        .container {
            display: flex;
        }

        .left {
            width: 50%;
        }

        .right {
            width: 37%;
        }

        .out {
            flex: 1;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="left">
            <div id="father" style="position:fixed;top: 50%;transform: translateY(-50%)">
                <canvas id="gc"></canvas>
                <canvas id="gc2"></canvas>
            </div>
        </div>
        <div class="right">
            <div style="width: 100%;">
                <h2>脚本</h2>
                <textarea id="ed2" oninput="inChange2()" rows="7" style="font-size:20px;font-weight:bold;width:70%;">
Hz /*帧率*/= 60;
color /*颜色*/= ["blue"];
p_b /*点精度*/= 200;
p_n /*线精度*/= 1;
ls /*线粗细*/= 2;
ps /*点大小*/= 0.5;
def /*定义*/= {love: 520, you: 1314/520};</textarea>
                <h2>表达式</h2>
                <textarea id="ed" oninput="inChange()" rows="6" style="font-size:20px;font-weight:bold;width:70%;">
sin(10x+time/100)/10</textarea>
                <img id="img" />
            </div>
            <h3 id="fpsm" style="position:fixed; top:0px; right:20px"></h3>

            <h3>简要说明</h3>
            <div>
                本程序正在开发中，目前还处于极度不完善状态，可能会有很多bug。开发者：烧风
                <br>支持的所有常量，请参考：https://mathjs.org/docs/reference/constants.html
                <br>支持的所有函数，请参考：https://mathjs.org/docs/reference/functions.html
                <br>图像的绘制范围固定在区间[-1,1]中，你可通过图像的平移和缩放得到你想要的效果
                <br> ● 支持直接输入函数绘制曲线，例如 sin(x) x^x gamma(x) E^x isPrime(x) x%0.5 等
                <br> ● 支持分段函数，请使用三元运算符 x&lt;0?x:x^2-x 或者 min() max() 等
                <br> ● 支持参数方程（参数为k，从0到1）绘制曲线，例如 k+k*i [k,k^2]/2-0.25 等
                <br> ● 支持输入不等式绘制平面区域（支持与或运算），例如 sin(x)&lt;y and y&lt;-0.2 等
                <br> ● 支持极坐标绘制曲线或者平面区域（使用 ρ 和 θ ），例如 ρ&lt;0.5 ρ&lt;θ ρ-0.1 等
                <br> ● 使用 time 返回当前时间戳，一般的使用方法是 sin(time/1000)
                <br> ● 支持绘制多个函数图像，回车换行输入，支持自定义函数，例如 f(x,y)=x^y
                <br> ● 使用 rgb(r,g,b) 命令改变绘制的颜色，例如 rgb(0,255,0)
                <br>你每改变一次输入框里的内容就会执行math.js的evaluate函数（参考文档：https://mathjs.org/）
                <br>表达式只要返回的是number或者boolean就可以绘制图像，所以可绘制的图像种类很多
                <br>欢迎挑战游戏《函数大冒险》https://hk-shao.github.io/demo/MyGame/FuncAdventure.html
            </div>
            </p>
        </div>
        <div class="out">
            <h2>输出</h2>
            <h3 id="outm"></h3>
        </div>
    </div>
</body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.1/math.min.js"></script>
<script type="text/javascript">
    cfa = document.getElementById("father");
    canv = document.getElementById("gc");
    ctx = canv.getContext("2d");
    canv2 = document.getElementById("gc2");
    ctx2 = canv2.getContext("2d");
    ined = document.getElementById("ed");
    ined2 = document.getElementById("ed2");
    outm = document.getElementById("outm");
    fpsm = document.getElementById("fpsm");
    img = document.getElementById("img");

    size = Math.min(window.innerWidth * 0.5, window.innerHeight * 0.95);
    cfa.style.width = size + "px";
    cfa.style.height = size + "px";
    canv.width = size;
    canv.height = size;
    canv2.width = size;
    canv2.height = size;

    interval = 0;
    inChange2();
    x = NaN;
    y = NaN;
    k = NaN;
    t1 = new Date().getTime();
    intmp = ""
    excs = [];
    mg = {};
    col = color[0];
    Object.assign(def, { rgb: function (r, g, b) { col = "rgb(" + r + "," + g + "," + b + ")"; } });

    reCanvas2();
    reCanvas();

    function reCanvas() {
        canv.width = canv.width;
    }

    function reCanvas2() {
        canv2.width = canv2.width;
        ctx2.strokeStyle = 'gray';
        ctx2.moveTo(size / 2, 0);
        ctx2.lineTo(size / 2, size);
        ctx2.moveTo(0, size / 2);
        ctx2.lineTo(size, size / 2);
        ctx2.stroke();
    }

    function plot(exc, type) {
        ctx.fillStyle = col;
        time = new Date().getTime();
        if (type == "boolean") {
            jd = size / p_b;
            for (var i = 0; i <= size; i += jd) {
                for (var j = 0; j <= size; j += jd) {
                    x = (2 * i - size) / size;
                    y = -(2 * j - size) / size;
                    Object.assign(mg, { x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time });
                    ans = exc.evaluate(mg);
                    if (ans == true) {
                        ctx.fillRect(i, j, jd * ps, jd * ps);
                    }
                }
            }
        } else if (type == "number") {
            for (var i = -p_n * size; i <= p_n * size; i++) {
                x = i / (p_n * size);
                Object.assign(mg, { x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time });
                y = exc.evaluate(mg);
                if (y > 1 || y < -1 || isNaN(y)) {
                    continue;
                }
                ctx.fillRect((x + 1) * 0.5 * size - 1, (1 - y) * size * 0.5 - 1, ls, ls);
            }
        } else if (type == "object") {
            Object.assign(mg, { x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), k: k, time: time });
            ob = exc.evaluate(mg);
            if (ob.im != undefined || (ob._data.length == 2 && typeof ob._data[0] == "number" && typeof ob._data[1] == "number")) {
                for (var i = 0; i <= 2 * p_n * size; i++) {
                    t = i / (2 * p_n * size);
                    Object.assign(mg, { x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), k: t, time: time });
                    ob = exc.evaluate(mg);
                    if (ob.im != undefined) {
                        x = ob.re;
                        y = ob.im;
                    } else {
                        x = ob._data[0];
                        y = ob._data[1];
                    }
                    if (y > 1 || y < -1 || x > 1 || x < -1 || isNaN(x) || isNaN(y)) {
                        continue;
                    }
                    ctx.fillRect((x + 1) * 0.5 * size - 1, (1 - y) * size * 0.5 - 1, ls, ls);
                }
            }
        }
    }

    function changeOm(str) {
        if (str != outm.innerHTML) {
            outm.innerHTML = str;
        }
    }

    function splot(exs) {
        omes = "";
        mg = {};
        if (excs.length == 0) {
            for (var i = 0; i < exs.length; i++) {
                try {
                    excs.push(math.compile(exs[i]));
                } catch (err) {
                    omes += "Error: Line " + (i + 1) + "<br>";
                    ined.style.border = "dashed red";
                    continue;
                }
            }
        }
        ci = 0;
        time = new Date().getTime();
        Object.assign(mg, { x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), k: k, time: time }, def);
        for (var i = 0; i < excs.length; i++) {
            Object.assign(mg, { x: NaN, y: NaN, ρ: NaN, θ: NaN });

            exc = excs[i];
            ined.style.border = "dashed green";
            col = color[ci++];
            try {
                outeval = exc.evaluate(mg);
                type = typeof outeval;
                if (type != "function") {
                    omes += outeval + "<br>";
                    if (!((Math.abs(outeval) == Infinity) && type != "object")) {
                        plot(exc, type);
                    }
                } else {
                    omes += "function" + "<br>";
                }
            } catch (err) {
                omes += "Error: Line " + (i + 1) + "<br>";
                ined.style.border = "dashed red";
            }
        }
        return omes;
    }

    function showLaTex(str) {
        if (img.alt != str) {
            img.src = "https://www.zhihu.com/equation?tex=" + encodeURIComponent(str);
            img.alt = str;
        }
    }

    function inChange() {
        if (ined.value != intmp || ined.value.indexOf("time") != -1 || excs.length == 0) {
            reCanvas();
            if (ined.value != "") {
                try {
                    showLaTex(math.parse(ined.value).toTex());
                } catch (err) {
                    showLaTex("");
                }
                if (ined.value == "0/0" || ined.value == "NaN") {
                    changeOm("NaN");
                }
                else {
                    if (ined.value != intmp) {
                        excs = [];
                    }
                    exs = ined.value.split("\n");
                    omes = splot(exs);
                    changeOm(omes);
                }
            } else {
                ined.style.border = "dashed red";
                showLaTex("");
                changeOm("Undefined");
            }
            intmp = ined.value;
        }
        t2 = new Date().getTime();
        if (t2 % 500 < 10) {
            fpsm.innerHTML = Math.round(1000 / (t2 - t1)) + " fps";
        }
        t1 = t2;
    }

    function inChange2() {
        ined2.style.border = "dashed green";
        try {
            eval(ined2.value);
            excs = [];
        } catch (err) {
            ined2.style.border = "dashed red";
        }
        window.clearInterval(interval);
        if (Hz != 0) {
            interval = setInterval("inChange()", Math.ceil(1000 / Hz));
        } else {
            fpsm.innerHTML = "0 fps";
        }
    }
</script>

</html>
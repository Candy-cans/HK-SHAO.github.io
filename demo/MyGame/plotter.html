<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>函数绘图（开发中v1.6beta5）</title>
    <style type="text/css">
        #father {
            position: fixed;
            top: 50%;
            transform: translateY(-50%)
        }

        #father #gc {
            border: solid;
            position: absolute;
            z-index: 2;
        }

        #father #gc2 {
            border: solid;
            position: absolute;
            z-index: 1;
        }

        .container {
            display: flex;
        }

        .right {
            width: 37%;
        }

        .out {
            flex: 1;
            width: 13%;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="left" id="lft">
            <div id="father">
                <canvas id="gc" onmouseout="reCanvas2()"></canvas>
                <canvas id="gc2"></canvas>
            </div>
        </div>
        <div class="right">
            <div style="width: 100%;">
                <h2>脚本</h2>
                <textarea id="ed2" oninput="inChange2()" rows="7" style="font-size:20px;font-weight:bold;width:70%;">
fps /*帧率*/= 60;
color /*颜色*/= ["blue"];
p_b /*点精度*/= 200;
ps /*点大小*/= 0.5;
p_n /*线精度*/= 1;
ls /*线粗细*/= 1;
def /*定义*/= {love: 520, you: 1314/520};</textarea>
                <h2>表达式</h2>
                <textarea id="ed" oninput="inChange()" rows="6"
                    style="font-size:24px;font-weight:bold;width:70%;font-family:'Times New Roman', Times, serif">
sin(10x+time/100)/10</textarea>
                <img id="img" style="max-width: 100%;height: auto;margin-top: 10px" />
            </div>
            <h3 id="fpsm" style="position:fixed; bottom:0px; right:20px"></h3>
            <h3>简要说明</h3>
            <div style="word-wrap:break-word">
                本程序正在开发中，目前还处于极度不完善状态，可能会有很多bug。开发者：烧风
                <br>支持的所有常量，请参考：https://mathjs.org/docs/reference/constants.html
                <br>支持的所有函数，请参考：https://mathjs.org/docs/reference/functions.html
                <br>图像的绘制范围固定在区间[-1,1]中，可通过函数的平移和缩放得到你想要的效果
                <br>表达式只要返回数字、布尔值、复数、二维矩阵，三维矩阵就可以绘制图像
                <br>在脚本里可以写javascript脚本，修改color数组可以修改绘制的色彩
                <br>回车换行输入可绘制多个函数图像
                <br>
                <br> ● 支持绘制多种函数曲线，例如 sin(x) x^x e^x gamma(x) x%0.5 等
                <br> ★ 特点：支持这些绘图 isPrime(x) x=sin(pi*y) ρ=cos(2θ) θ=ρ^ρ 等
                <br> ● 支持分段函数，请使用三元运算符 x&lt;0?x:x^2-x 或者 min() max() 等
                <br> ● 支持参数方程（参数从0到1），例如 k+k*i [k,k^2]/2-0.25 ρθ(k,k) xy(k,k)等
                <br> ● 支持输入不等式绘制平面区域（支持与或运算），例如 sin(x)&lt;y and y&lt;-0.2 等
                <br> ● 支持极坐标绘制曲线或者平面区域（使用ρ和θ），例如 ρ&lt;0.5 ρ&lt;θ ρ-0.1 等
                <br> ● 支持三维矩阵进行着色（建议将点大小改为1.5以上），例如 [x,y^2,x*y]
                <br> ● 支持自定义变量和函数，例如 [n=2,f(x,y)=x^y,f(x,n)][3]
                <br> ● 使用 time 返回当前时间戳，一般的使用方法是 sin(time/1000)
                <br> ● 使用 frame 返回帧数。使用 mp 返回当前光标的位置，例如 (x-mp[1])^2+mp[2]
            </div>
            </p>
        </div>
        <div class="out">
            <h2>输出</h2>
            <h3 id="outm" style="word-wrap:break-word"></h3>
        </div>
    </div>
</body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.1/math.min.js"></script>
<script type="text/javascript">
    const cfa = document.getElementById("father");
    const canv = document.getElementById("gc");
    const ctx = canv.getContext("2d");
    const canv2 = document.getElementById("gc2");
    const ctx2 = canv2.getContext("2d");
    const ined = document.getElementById("ed");
    const ined2 = document.getElementById("ed2");
    const outm = document.getElementById("outm");
    const fpsm = document.getElementById("fpsm");
    const img = document.getElementById("img");
    const lft = document.getElementById("lft");

    window.onload = function () {
        mxf = 0;
        myf = 0;
        interval = 0;
        inChange2();
        x = NaN;
        y = NaN;
        frame = 0;
        intmp = ""
        excs = [];
        col = color[0];
        math.import(
            {
                hkshao: function () {
                    return "恭喜你发现这个彩蛋！";
                },
                π: Math.PI,
                xy: function (x, y) {
                    return math.matrix([x, y]);
                },
                ρθ: function (ρ, θ) {
                    return math.matrix([ρ * Math.cos(θ), ρ * Math.sin(θ)]);
                }
            });
        window.onresize();
        canv.addEventListener("mousemove", mouseMove);
    }

    window.onresize = function () {
        size = Math.min(window.innerWidth / 2, window.innerHeight * 0.95);
        lft.style.width = size + 16 + "px";
        cfa.style.width = size + "px";
        cfa.style.height = size + "px";
        canv.width = size;
        canv.height = size;
        canv2.width = size;
        canv2.height = size;
        reCanvas2();
        inChange(true);
    }

    function mouseMove(e) {
        let cRect = canv2.getBoundingClientRect();
        let mx = Math.round(e.clientX - cRect.left);
        let my = Math.round(e.clientY - cRect.top);
        canv2.width = canv2.height;
        ctx2.strokeStyle = 'gray';
        ctx2.setLineDash([size / 201, size / 201]);
        ctx2.moveTo(size / 2, 0);
        ctx2.lineTo(size / 2, size);
        ctx2.moveTo(0, size / 2);
        ctx2.lineTo(size, size / 2);
        ctx2.moveTo(size / 2, my);
        ctx2.lineTo(mx, my);
        ctx2.moveTo(mx, size / 2);
        ctx2.lineTo(mx, my);
        mxf = (2 * mx / size) - 1;
        myf = (-2 * my / size) + 1;
        ctx2.stroke();
        ctx2.fillText("(" + mxf.toFixed(8) + ", " + myf.toFixed(8) + ")", 4, 14);
        if (ined.value.indexOf("mp") != -1) {
            inChange(true);
        }
    }

    function reCanvas() {
        ctx.clearRect(0, 0, size, size);
    }

    function reCanvas2() {
        canv2.width = canv2.height;
        ctx2.strokeStyle = 'gray';
        ctx2.setLineDash([size / 101, size / 101]);
        ctx2.moveTo(size / 2, 0);
        ctx2.lineTo(size / 2, size);
        ctx2.moveTo(0, size / 2);
        ctx2.lineTo(size, size / 2);
        ctx2.stroke();
    }

    function plot(ex, exc, outeval) {
        ctx.fillStyle = col;
        frame += 1;
        let time = new Date().getTime();
        let ins2 = ex.substring(0, 2);
        if (ins2 == "x=") {
            for (let i = -p_n * size; i <= p_n * size; i++) {
                y = i / (p_n * size);
                let mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                x = exc.evaluate(mg);
                if (x > 1 || x < -1 || isNaN(x)) {
                    continue;
                }
                let py = 0.004 * size * ls;
                ctx.fillRect((x + 1) / 2 * size - 1, (1 - y) * size / 2 - 1, py, py);
            }
        } else if (ins2 == "ρ=") {
            for (let i = 0; i <= 2 * p_n * size; i++) {
                let θ = Math.PI * i / (p_n * size);
                let mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: θ, time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                let ρ = exc.evaluate(mg);
                x = ρ * Math.cos(θ);
                y = ρ * Math.sin(θ);
                if (y > 1 || y < -1 || x > 1 || x < -1 || isNaN(x) || isNaN(y)) {
                    continue;
                }
                let py = 0.004 * size * ls;
                ctx.fillRect((x + 1) / 2 * size - 1, (1 - y) * size / 2 - 1, py, py);
            }
        } else if (ins2 == "θ=") {
            for (let i = 0; i <= 2 * p_n * size; i++) {
                let ρ = Math.SQRT2 * i / (2 * p_n * size);
                let mg = Object.assign({ x: x, y: y, ρ: ρ, θ: Math.atan2(y, x), time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                let θ = exc.evaluate(mg);
                x = ρ * Math.cos(θ);
                y = ρ * Math.sin(θ);
                if (y > 1 || y < -1 || x > 1 || x < -1 || isNaN(x) || isNaN(y)) {
                    continue;
                }
                let py = 0.004 * size * ls;
                ctx.fillRect((x + 1) / 2 * size - 1, (1 - y) * size / 2 - 1, py, py);
            }
        } else if (ins2 == "y=" || typeof outeval == "number") {
            for (let i = -p_n * size; i <= p_n * size; i++) {
                x = i / (p_n * size);
                let mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                y = exc.evaluate(mg);
                if (y > 1 || y < -1 || isNaN(y)) {
                    continue;
                }
                let py = 0.004 * size * ls;
                ctx.fillRect((x + 1) / 2 * size - 1, (1 - y) * size / 2 - 1, py, py);
            }
        } else if (typeof outeval == "boolean") {
            let jd = size / p_b;
            for (let i = 0; i <= size; i += jd) {
                for (let j = 0; j <= size; j += jd) {
                    x = (2 * i - size) / size;
                    y = -(2 * j - size) / size;
                    let mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                    let ans = exc.evaluate(mg);
                    if (ans == true) {
                        let py = jd * ps;
                        ctx.fillRect(i, j, py, py);
                    }
                }
            }
        } else if (typeof outeval == "object") {
            if (outeval.im != undefined) {
                for (let i = 0; i <= 2 * p_n * size; i++) {
                    let t = i / (2 * p_n * size);
                    let mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), k: t, time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                    let ob = exc.evaluate(mg);
                    x = ob.re;
                    y = ob.im;
                    if (y > 1 || y < -1 || x > 1 || x < -1 || isNaN(x) || isNaN(y)) {
                        continue;
                    }
                    let py = 0.004 * size * ls;
                    ctx.fillRect((x + 1) / 2 * size - 1, (1 - y) * size / 2 - 1, py, py);
                }
            } else if (outeval._data.length == 2) {
                for (let i = 0; i <= 2 * p_n * size; i++) {
                    let t = i / (2 * p_n * size);
                    let mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), k: t, time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                    let ob = exc.evaluate(mg);
                    x = ob._data[0];
                    y = ob._data[1];
                    if (y > 1 || y < -1 || x > 1 || x < -1 || isNaN(x) || isNaN(y)) {
                        continue;
                    }
                    let py = 0.004 * size * ls;
                    ctx.fillRect((x + 1) / 2 * size - 1, (1 - y) * size / 2 - 1, py, py);
                }
            } else if (outeval._data.length == 3) {
                let jd = size / p_b;
                for (let i = 0; i <= size; i += jd) {
                    for (let j = 0; j <= size; j += jd) {
                        x = (2 * i - size) / size;
                        y = -(2 * j - size) / size;
                        let mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                        let ob = exc.evaluate(mg);
                        let r = ob._data[0] * 255;
                        let g = ob._data[1] * 255;
                        let b = ob._data[2] * 255;
                        if (isNaN(r) || isNaN(g) || isNaN(b)) {
                            continue;
                        }
                        ctx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
                        let py = jd * ps;
                        ctx.fillRect(i, j, py, py);
                    }
                }
            }
        } else {
            frame -= 1;
        }
    }

    function changeOm(str) {
        if (str != outm.innerHTML) {
            outm.innerHTML = str;
        }
    }

    function splot(exs) {
        let omes = "";
        if (excs.length == 0) {
            for (let i = 0; i < exs.length; i++) {
                try {
                    excs.push(math.compile(exs[i]));
                } catch (err) {
                    omes += "CompileError: Line " + (i + 1) + "<br>";
                    ined.style.border = "dashed red";
                    continue;
                }
            }
        }
        let ci = 0;
        let time = new Date().getTime();
        for (let i = 0; i < excs.length; i++) {
            let exc = excs[i];
            ined.style.border = "dashed green";
            let mg = Object.assign({ x: NaN, y: NaN, ρ: NaN, θ: NaN, k: NaN, time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
            try {
                let outeval = exc.evaluate(mg);
                let type = typeof outeval;
                if (type != "function") {
                    omes += outeval + "<br>";
                    if (Math.abs(outeval) != Infinity) {
                        col = color[ci++];
                        plot(exs[i], exc, outeval);
                    }
                } else {
                    omes += "function" + "<br>";
                }
            } catch (err) {
                omes += "PlotError: Line " + (i + 1) + "<br>";
                ined.style.border = "dashed red";
            }
        }
        return omes;
    }

    function showLaTex(str) {
        if (img.alt != str) {
            img.src = "https://www.zhihu.com/equation?tex=" + encodeURIComponent(str.replace(/\\;\\;/g, "\\\\"));
            img.alt = str;
        }
    }

    function inChange(isD = false) {
        if (ined.value != intmp || ined.value.indexOf("time") != -1 || ined.value.indexOf("frame") != -1 || isD || excs.length == 0) {
            if (ined.value != intmp) {
                t1 = new Date().getTime();
                excs = [];
                frame = 0;
            }
            intmp = ined.value;
            reCanvas();
            if (ined.value != "") {
                try {
                    showLaTex(math.parse(ined.value).toTex());
                } catch (err) {
                    showLaTex("");
                }
                if (ined.value == "0/0" || ined.value == "NaN") {
                    changeOm("NaN");
                    return;
                }
                let exs = ined.value.split("\n");
                ined.rows = exs.length > 4 ? exs.length : 5;
                let omes = splot(exs);
                changeOm(omes);
            } else {
                ined.style.border = "dashed red";
                showLaTex("");
                changeOm("Undefined");
            }
        }
        let t2 = new Date().getTime();
        if (t2 % 500 < 10) {
            fpsm.innerHTML = Math.round(1000 / (t2 - t1)) + " fps";
        }
        t1 = t2;
    }

    function inChange2() {
        ined2.style.border = "dashed green";
        ined2.rows = ined2.value.split("\n").length;
        try {
            eval(ined2.value);
            excs = [];
        } catch (err) {
            ined2.style.border = "dashed red";
        }
        window.clearInterval(interval);
        if (fps != 0) {
            interval = setInterval("inChange()", Math.ceil(1000 / fps));
        } else {
            fpsm.innerHTML = "0 fps";
        }
    }
</script>

</html>
<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>函数绘图（开发中v1.5）</title>
    <style type="text/css">
        #father {
            border: solid;
            position: fixed;
            top: 50%;
            transform: translateY(-50%)
        }

        #father #gc {
            position: absolute;
            opacity: 0.8;
            z-index: 2;
        }

        #father #gc2 {
            position: absolute;
            z-index: 1;
        }

        .container {
            display: flex;
        }

        .right {
            width: 37%;
        }

        .out {
            flex: 1;
            width: 13%;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="left" id="lft">
            <div id="father">
                <canvas id="gc" onmouseout="reCanvas2()"></canvas>
                <canvas id="gc2"></canvas>
            </div>
        </div>
        <div class="right">
            <div style="width: 100%;">
                <h2>脚本</h2>
                <textarea id="ed2" oninput="inChange2()" rows="7" style="font-size:20px;font-weight:bold;width:70%;">
Hz /*帧率*/= 60;
color /*颜色*/= ["blue"];
p_b /*点精度*/= 200;
p_n /*线精度*/= 1;
ls /*线粗细*/= 2;
ps /*点大小*/= 0.5;
def /*定义*/= {love: 520, you: 1314/520};</textarea>
                <h2>表达式</h2>
                <textarea id="ed" oninput="inChange()" rows="6" style="font-size:20px;font-weight:bold;width:70%;">
sin(10x+time/100)/10</textarea>
                <img id="img" />
            </div>
            <h3 id="fpsm" style="position:fixed; bottom:0px; right:20px"></h3>
            <h3>简要说明</h3>
            <div>
                本程序正在开发中，目前还处于极度不完善状态，可能会有很多bug。开发者：烧风
                <br>支持的所有常量，请参考：https://mathjs.org/docs/reference/constants.html
                <br>支持的所有函数，请参考：https://mathjs.org/docs/reference/functions.html
                <br>图像的绘制范围固定在区间[-1,1]中，可通过函数的平移和缩放得到你想要的效果
                <br>表达式只要返回数字、布尔值、复数、二维矩阵就可以绘制图像
                <br>在脚本里可以写javascript脚本，修改color数组可以修改绘制的色彩
                <br>回车换行输入可绘制多个函数图像
                <br>
                <br> ● 支持直接输入函数绘制曲线，例如 sin(x) x^x gamma(x) E^x isPrime(x) x%0.5 等
                <br> ● 支持分段函数，请使用三元运算符 x&lt;0?x:x^2-x 或者 min() max() 等
                <br> ● 支持参数方程（参数为k，从0到1）绘制曲线，例如 k+k*i [k,k^2]/2-0.25 等
                <br> ● 支持输入不等式绘制平面区域（支持与或运算），例如 sin(x)&lt;y and y&lt;-0.2 等
                <br> ● 支持极坐标绘制曲线或者平面区域（使用 ρ 和 θ ），例如 ρ&lt;0.5 ρ&lt;θ ρ-0.1 等
                <br> ● 支持自定义变量和函数，例如 [n=2,f(x,y)=x^y,f(x,n)][3]
                <br> ● 使用 time 返回当前时间戳，一般的使用方法是 sin(time/1000)
                <br> ● 使用 frame 返回帧数。使用 mp 返回当前光标的位置，例如 (x-mp[1])^2+mp[2]
            </div>
            </p>
        </div>
        <div class="out">
            <h2>输出</h2>
            <h3 id="outm"></h3>
        </div>
    </div>
</body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.1/math.min.js"></script>
<script type="text/javascript">
    cfa = document.getElementById("father");
    canv = document.getElementById("gc");
    ctx = canv.getContext("2d");
    canv2 = document.getElementById("gc2");
    ctx2 = canv2.getContext("2d");
    ined = document.getElementById("ed");
    ined2 = document.getElementById("ed2");
    outm = document.getElementById("outm");
    fpsm = document.getElementById("fpsm");
    img = document.getElementById("img");
    lft = document.getElementById("lft");

    window.onresize = function () {
        size = Math.min(window.innerWidth * 0.5, window.innerHeight * 0.95);
        lft.style.width = size + 16 + "px";
        cfa.style.width = size + "px";
        cfa.style.height = size + "px";
        canv.width = size;
        canv.height = size;
        canv2.width = size;
        canv2.height = size;
        reCanvas2();
    }

    window.onresize();

    mxf = 0;
    myf = 0;
    canv.addEventListener("mousemove", function (e) {
        cRect = canv2.getBoundingClientRect();
        mx = Math.round(e.clientX - cRect.left);
        my = Math.round(e.clientY - cRect.top);
        canv2.width = canv2.width;
        ctx2.strokeStyle = 'gray';
        ctx2.setLineDash([size / 201, size / 201]);
        ctx2.moveTo(size / 2, 0);
        ctx2.lineTo(size / 2, size);
        ctx2.moveTo(0, size / 2);
        ctx2.lineTo(size, size / 2);
        ctx2.moveTo(size / 2, my);
        ctx2.lineTo(mx, my);
        ctx2.moveTo(mx, size / 2);
        ctx2.lineTo(mx, my);
        mxf = (2 * mx / size) - 1;
        myf = (-2 * my / size) + 1;
        ctx2.fillText("(" + mxf + ", " + myf + ")", 4, 14);
        ctx2.stroke();
        if (ined.value.indexOf("mp") != -1) {
            inChange(true);
        }
    });

    interval = 0;
    inChange2();
    x = NaN;
    y = NaN;
    k = NaN;
    t1 = new Date().getTime();
    frame = 0;
    intmp = ""
    excs = [];
    col = color[0];
    Object.assign(def,
        {
            hkshao: function () {
                return "恭喜你发现这个彩蛋！"
            }
        });

    function reCanvas() {
        ctx.clearRect(0, 0, size, size);
    }

    function reCanvas2() {
        canv2.width = canv2.width;
        ctx2.strokeStyle = 'gray';
        ctx2.setLineDash([size / 101, size / 101]);
        ctx2.moveTo(size / 2, 0);
        ctx2.lineTo(size / 2, size);
        ctx2.moveTo(0, size / 2);
        ctx2.lineTo(size, size / 2);
        ctx2.stroke();
    }

    function plot(exc, type) {
        ctx.fillStyle = col;
        frame += 1;
        time = new Date().getTime();
        if (type == "boolean") {
            jd = size / p_b;
            for (var i = 0; i <= size; i += jd) {
                for (var j = 0; j <= size; j += jd) {
                    x = (2 * i - size) / size;
                    y = -(2 * j - size) / size;
                    mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                    ans = exc.evaluate(mg);
                    if (ans == true) {
                        ctx.fillRect(i, j, jd * ps, jd * ps);
                    }
                }
            }
        } else if (type == "number") {
            for (var i = -p_n * size; i <= p_n * size; i++) {
                x = i / (p_n * size);
                mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                y = exc.evaluate(mg);
                if (y > 1 || y < -1 || isNaN(y)) {
                    continue;
                }
                ctx.fillRect((x + 1) * 0.5 * size - 1, (1 - y) * size * 0.5 - 1, ls, ls);
            }
        } else if (type == "object") {
            mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), k: NaN, time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
            ob = exc.evaluate(mg);
            if (ob.im != undefined || (ob._data.length == 2 && typeof ob._data[0] == "number" && typeof ob._data[1] == "number")) {
                for (var i = 0; i <= 2 * p_n * size; i++) {
                    t = i / (2 * p_n * size);
                    mg = Object.assign({ x: x, y: y, ρ: Math.sqrt(x * x + y * y), θ: Math.atan2(y, x), k: t, time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
                    ob = exc.evaluate(mg);
                    if (ob.im != undefined) {
                        x = ob.re;
                        y = ob.im;
                    } else {
                        x = ob._data[0];
                        y = ob._data[1];
                    }
                    if (y > 1 || y < -1 || x > 1 || x < -1 || isNaN(x) || isNaN(y)) {
                        continue;
                    }
                    ctx.fillRect((x + 1) * 0.5 * size - 1, (1 - y) * size * 0.5 - 1, ls, ls);
                }
            }
        } else {
            frame -= 1;
        }
    }

    function changeOm(str) {
        if (str != outm.innerHTML) {
            outm.innerHTML = str;
        }
    }

    function splot(exs) {
        omes = "";
        if (excs.length == 0) {
            for (var i = 0; i < exs.length; i++) {
                try {
                    excs.push(math.compile(exs[i]));
                } catch (err) {
                    omes += "Error: Line " + (i + 1) + "<br>";
                    ined.style.border = "dashed red";
                    continue;
                }
            }
        }
        ci = 0;
        time = new Date().getTime();
        for (var i = 0; i < excs.length; i++) {
            exc = excs[i];
            ined.style.border = "dashed green";
            mg = Object.assign({ x: NaN, y: NaN, ρ: NaN, θ: NaN, k: NaN, time: time, frame: frame, mp: math.matrix([mxf, myf]) }, def);
            try {
                outeval = exc.evaluate(mg);
                type = typeof outeval;
                if (type != "function") {
                    omes += outeval + "<br>";
                    if (!((Math.abs(outeval) == Infinity) && type != "object")) {
                        col = color[ci++];
                        plot(exc, type);
                    }
                } else {
                    omes += "function" + "<br>";
                }
            } catch (err) {
                omes += "Error: Line " + (i + 1) + "<br>";
                ined.style.border = "dashed red";
            }
        }
        return omes;
    }

    function showLaTex(str) {
        if (img.alt != str) {
            img.src = "https://www.zhihu.com/equation?tex=" + encodeURIComponent(str);
            img.alt = str;
        }
    }

    function inChange(isD = false) {
        if (ined.value != intmp || ined.value.indexOf("time") != -1 || ined.value.indexOf("frame") != -1 || isD || excs.length == 0) {
            reCanvas();
            if (ined.value != "") {
                try {
                    showLaTex(math.parse(ined.value).toTex());
                } catch (err) {
                    showLaTex("");
                }
                if (ined.value == "0/0" || ined.value == "NaN") {
                    changeOm("NaN");
                }
                else {
                    if (ined.value != intmp) {
                        excs = [];
                        frame = 0;
                    }
                    exs = ined.value.split("\n");
                    omes = splot(exs);
                    changeOm(omes);
                }
            } else {
                ined.style.border = "dashed red";
                showLaTex("");
                changeOm("Undefined");
            }
            intmp = ined.value;
        }
        t2 = new Date().getTime();
        if (t2 % 500 < 10) {
            fpsm.innerHTML = Math.round(1000 / (t2 - t1)) + " fps";
        }
        t1 = t2;
    }

    function inChange2() {
        ined2.style.border = "dashed green";
        try {
            eval(ined2.value);
            excs = [];
        } catch (err) {
            ined2.style.border = "dashed red";
        }
        window.clearInterval(interval);
        if (Hz != 0) {
            interval = setInterval("inChange()", Math.ceil(1000 / Hz));
        } else {
            fpsm.innerHTML = "0 fps";
        }
    }
</script>

</html>
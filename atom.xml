<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HK-SHAO</title>
  
  <subtitle>Shao&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hk-shao.github.io/"/>
  <updated>2019-02-07T02:30:21.469Z</updated>
  <id>https://hk-shao.github.io/</id>
  
  <author>
    <name>王家晔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习中的一个尝试——“机器创造”</title>
    <link href="https://hk-shao.github.io/2019/02/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%9D%E8%AF%95%E2%80%94%E2%80%94%E2%80%9C%E6%9C%BA%E5%99%A8%E5%88%9B%E9%80%A0%E2%80%9D/"/>
    <id>https://hk-shao.github.io/2019/02/07/机器学习中的一个尝试——“机器创造”/</id>
    <published>2019-02-07T01:00:47.000Z</published>
    <updated>2019-02-07T02:30:21.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从识别数字开始"><a href="#从识别数字开始" class="headerlink" title="从识别数字开始"></a>从识别数字开始</h2><p>MNIST文件中包含了几万个手写数字的灰度图片，这些图片尺寸是28<em> 28，灰度值为[0, 128)，机器学习有两个入门的“Hello World”，除了做散点图的回归直线外，就是识别手写数字，这个过程一般涉及三个神经网络层，输入层（28 </em>28 = 784个神经元），隐藏层（神经元个数按需决定），输出层（10个神经元，代表10个可能的数字）。所以将模型建好后，训练模型，优化所有的神经元权重和偏移，使得残差平方的平均值loss降到最低。得到的模型后，将含有784个数值的矩阵X（也就是手写的数字图片）输入到模型中，经过一层层神经元，最后映射到一个含有10个数值的矩阵Y（也就是 Y = f(X) ），这个矩阵有10个数值，每个数值代表相应数字的概率。我们选取概率最大的那个，这样就实现了输入一张手写数字图片，输出这张图片上所写的数字。经过百万次训练，这个准确率可以达到95%以上。<br><img src="/images/blog/14.PNG" alt=""><a id="more"></a></p><h2 id="创造数字？"><a href="#创造数字？" class="headerlink" title="创造数字？"></a>创造数字？</h2><p>因为笔者刚刚接触机器学习，技术还很水，GAN什么的还搞不懂，于是单纯的想创造个模型，输入[0, 9]之间的数字，输出一张“手写数字图片”。如果 x, y, z 分别表示像素横坐标，像素纵坐标和数字[0, 9]，通过一个复杂的函数 f , 映射到像素灰度值y [0, 128), 也就是 y = f(x, y, z)。</p><p>我把函数设计的很简单：</p><p>$$<br> g(x, y, z) = \left[<br> \begin{matrix}<br>   a_{1} &amp; a_{2} &amp; a_{3}<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \<br>   y \<br>   z \<br>  \end{matrix}<br>  \right] + b_{1}<br>$$</p><p>$$<br> f(x, y, z) = \left[<br> \begin{matrix}<br>   a_{4} &amp; a_{5} &amp; a_{6}<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   g(x^2,y,z) \<br>   g(x,y^2,z) \<br>   g(x,y,z^2) \<br>  \end{matrix}<br>  \right] + \left[<br> \begin{matrix}<br>   a_{7} &amp; a_{8} &amp; a_{9}<br>  \end{matrix}<br>  \right] \left[<br> \begin{matrix}<br>   x \<br>   y \<br>   z \<br>  \end{matrix}<br>  \right] + b_{2}<br>$$</p><p>要问为啥这样设计，其实我也不知道（笑，随便设计一个玩一下。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="将MNIST文件中所有图片和对于标签保存成csv文件"><a href="#将MNIST文件中所有图片和对于标签保存成csv文件" class="headerlink" title="将MNIST文件中所有图片和对于标签保存成csv文件"></a>将MNIST文件中所有图片和对于标签保存成csv文件</h3><p>x, y, c, l分别是像素横坐标，纵坐标，灰度值，数字标签，保存成文件有655MB大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集文件</span></span><br><span class="line">train_images_idx3_ubyte_file = <span class="string">'MNIST_data/train-images.idx3-ubyte'</span></span><br><span class="line"><span class="comment"># 训练集标签文件</span></span><br><span class="line">train_labels_idx1_ubyte_file = <span class="string">'MNIST_data/train-labels.idx1-ubyte'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集文件</span></span><br><span class="line">test_images_idx3_ubyte_file = <span class="string">'MNIST_data/t10k-images.idx3-ubyte'</span></span><br><span class="line"><span class="comment"># 测试集标签文件</span></span><br><span class="line">test_labels_idx1_ubyte_file = <span class="string">'MNIST_data/t10k-labels.idx1-ubyte'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_idx3_ubyte</span><span class="params">(idx3_ubyte_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    解析idx3文件的通用函数</span></span><br><span class="line"><span class="string">    :param idx3_ubyte_file: idx3文件路径</span></span><br><span class="line"><span class="string">    :return: 数据集</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 读取二进制数据</span></span><br><span class="line">    bin_data = open(idx3_ubyte_file, <span class="string">'rb'</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析文件头信息，依次为魔数、图片数量、每张图片高、每张图片宽</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    fmt_header = <span class="string">'&gt;iiii'</span> <span class="comment">#因为数据结构中前4行的数据类型都是32位整型，所以采用i格式，但我们需要读取前4行数据，所以需要4个i。我们后面会看到标签集中，只使用2个ii。</span></span><br><span class="line">    magic_number, num_images, num_rows, num_cols = struct.unpack_from(fmt_header, bin_data, offset)</span><br><span class="line">    print(<span class="string">'魔数:%d, 图片数量: %d张, 图片大小: %d*%d'</span> % (magic_number, num_images, num_rows, num_cols))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析数据集</span></span><br><span class="line">    image_size = num_rows * num_cols</span><br><span class="line">    offset += struct.calcsize(fmt_header)  <span class="comment">#获得数据在缓存中的指针位置，从前面介绍的数据结构可以看出，读取了前4行之后，指针位置（即偏移位置offset）指向0016。</span></span><br><span class="line">    print(offset)</span><br><span class="line">    fmt_image = <span class="string">'&gt;'</span> + str(image_size) + <span class="string">'B'</span>  <span class="comment">#图像数据像素值的类型为unsigned char型，对应的format格式为B。这里还有加上图像大小784，是为了读取784个B格式数据，如果没有则只会读取一个值（即一副图像中的一个像素值）</span></span><br><span class="line">    print(fmt_image,offset,struct.calcsize(fmt_image))</span><br><span class="line">    images = np.empty((num_images, num_rows, num_cols))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_images):</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'已解析 %d'</span> % (i + <span class="number">1</span>) + <span class="string">'张'</span>)</span><br><span class="line">            print(offset)</span><br><span class="line">        images[i] = np.array(struct.unpack_from(fmt_image, bin_data, offset)).reshape((num_rows, num_cols))</span><br><span class="line"></span><br><span class="line">        offset += struct.calcsize(fmt_image)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_idx1_ubyte</span><span class="params">(idx1_ubyte_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    解析idx1文件的通用函数</span></span><br><span class="line"><span class="string">    :param idx1_ubyte_file: idx1文件路径</span></span><br><span class="line"><span class="string">    :return: 数据集</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 读取二进制数据</span></span><br><span class="line">    bin_data = open(idx1_ubyte_file, <span class="string">'rb'</span>).read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析文件头信息，依次为魔数和标签数</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    fmt_header = <span class="string">'&gt;ii'</span></span><br><span class="line">    magic_number, num_images = struct.unpack_from(fmt_header, bin_data, offset)</span><br><span class="line">    print(<span class="string">'魔数:%d, 图片数量: %d张'</span> % (magic_number, num_images))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析数据集</span></span><br><span class="line">    offset += struct.calcsize(fmt_header)</span><br><span class="line">    fmt_image = <span class="string">'&gt;B'</span></span><br><span class="line">    labels = np.empty(num_images)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_images):</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'已解析 %d'</span> % (i + <span class="number">1</span>) + <span class="string">'张'</span>)</span><br><span class="line">        labels[i] = struct.unpack_from(fmt_image, bin_data, offset)[<span class="number">0</span>]</span><br><span class="line">        offset += struct.calcsize(fmt_image)</span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_train_images</span><span class="params">(idx_ubyte_file=train_images_idx3_ubyte_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    TRAINING SET IMAGE FILE (train-images-idx3-ubyte):</span></span><br><span class="line"><span class="string">    [offset] [type]          [value]          [description]</span></span><br><span class="line"><span class="string">    0000     32 bit integer  0x00000803(2051) magic number</span></span><br><span class="line"><span class="string">    0004     32 bit integer  60000            number of images</span></span><br><span class="line"><span class="string">    0008     32 bit integer  28               number of rows</span></span><br><span class="line"><span class="string">    0012     32 bit integer  28               number of columns</span></span><br><span class="line"><span class="string">    0016     unsigned byte   ??               pixel</span></span><br><span class="line"><span class="string">    0017     unsigned byte   ??               pixel</span></span><br><span class="line"><span class="string">    ........</span></span><br><span class="line"><span class="string">    xxxx     unsigned byte   ??               pixel</span></span><br><span class="line"><span class="string">    Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param idx_ubyte_file: idx文件路径</span></span><br><span class="line"><span class="string">    :return: n*row*col维np.array对象，n为图片数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> decode_idx3_ubyte(idx_ubyte_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_train_labels</span><span class="params">(idx_ubyte_file=train_labels_idx1_ubyte_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    TRAINING SET LABEL FILE (train-labels-idx1-ubyte):</span></span><br><span class="line"><span class="string">    [offset] [type]          [value]          [description]</span></span><br><span class="line"><span class="string">    0000     32 bit integer  0x00000801(2049) magic number (MSB first)</span></span><br><span class="line"><span class="string">    0004     32 bit integer  60000            number of items</span></span><br><span class="line"><span class="string">    0008     unsigned byte   ??               label</span></span><br><span class="line"><span class="string">    0009     unsigned byte   ??               label</span></span><br><span class="line"><span class="string">    ........</span></span><br><span class="line"><span class="string">    xxxx     unsigned byte   ??               label</span></span><br><span class="line"><span class="string">    The labels values are 0 to 9.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param idx_ubyte_file: idx文件路径</span></span><br><span class="line"><span class="string">    :return: n*1维np.array对象，n为图片数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> decode_idx1_ubyte(idx_ubyte_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_test_images</span><span class="params">(idx_ubyte_file=test_images_idx3_ubyte_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    TEST SET IMAGE FILE (t10k-images-idx3-ubyte):</span></span><br><span class="line"><span class="string">    [offset] [type]          [value]          [description]</span></span><br><span class="line"><span class="string">    0000     32 bit integer  0x00000803(2051) magic number</span></span><br><span class="line"><span class="string">    0004     32 bit integer  10000            number of images</span></span><br><span class="line"><span class="string">    0008     32 bit integer  28               number of rows</span></span><br><span class="line"><span class="string">    0012     32 bit integer  28               number of columns</span></span><br><span class="line"><span class="string">    0016     unsigned byte   ??               pixel</span></span><br><span class="line"><span class="string">    0017     unsigned byte   ??               pixel</span></span><br><span class="line"><span class="string">    ........</span></span><br><span class="line"><span class="string">    xxxx     unsigned byte   ??               pixel</span></span><br><span class="line"><span class="string">    Pixels are organized row-wise. Pixel values are 0 to 255. 0 means background (white), 255 means foreground (black).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param idx_ubyte_file: idx文件路径</span></span><br><span class="line"><span class="string">    :return: n*row*col维np.array对象，n为图片数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> decode_idx3_ubyte(idx_ubyte_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_test_labels</span><span class="params">(idx_ubyte_file=test_labels_idx1_ubyte_file)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    TEST SET LABEL FILE (t10k-labels-idx1-ubyte):</span></span><br><span class="line"><span class="string">    [offset] [type]          [value]          [description]</span></span><br><span class="line"><span class="string">    0000     32 bit integer  0x00000801(2049) magic number (MSB first)</span></span><br><span class="line"><span class="string">    0004     32 bit integer  10000            number of items</span></span><br><span class="line"><span class="string">    0008     unsigned byte   ??               label</span></span><br><span class="line"><span class="string">    0009     unsigned byte   ??               label</span></span><br><span class="line"><span class="string">    ........</span></span><br><span class="line"><span class="string">    xxxx     unsigned byte   ??               label</span></span><br><span class="line"><span class="string">    The labels values are 0 to 9.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param idx_ubyte_file: idx文件路径</span></span><br><span class="line"><span class="string">    :return: n*1维np.array对象，n为图片数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> decode_idx1_ubyte(idx_ubyte_file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    train_images = load_train_images()</span><br><span class="line"></span><br><span class="line">    train_labels = load_train_labels()</span><br><span class="line">    </span><br><span class="line">    csv_file = open(<span class="string">'data.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>)</span><br><span class="line">    csv_write = csv.writer(csv_file)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60000</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">28</span>):</span><br><span class="line">                c = train_images[i, x, y]</span><br><span class="line">                l = train_labels[i]</span><br><span class="line">                csv_write.writerow([x, y, c, l])</span><br><span class="line">    csv_file.close()</span><br></pre></td></tr></table></figure><h3 id="读取csv并且使用TensorFlow训练"><a href="#读取csv并且使用TensorFlow训练" class="headerlink" title="读取csv并且使用TensorFlow训练"></a>读取csv并且使用TensorFlow训练</h3><p>具体不多说了。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> tensorflow as tf</span><br><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line"><span class="built_in">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="attr">csv_file</span> = csv.reader(open('data.csv', <span class="attr">encoding</span> = 'utf-<span class="number">8</span>')) <span class="comment"># 以utf-8编码打开csv文件，然后用reader读取</span></span><br><span class="line"></span><br><span class="line">x_data, y_data, c_data, <span class="attr">l_data</span> = [], [], [], [] <span class="comment"># 分别是横坐标[0, 27]列表，纵坐标[0, 27]列表，灰度值[0, 128]列表，数字标签[0, 9]列表</span></span><br><span class="line"></span><br><span class="line"><span class="attr">n</span> = <span class="number">3000000</span> <span class="comment"># 读取的数据个数</span></span><br><span class="line">for data <span class="keyword">in</span> csv_file:</span><br><span class="line">    <span class="keyword">if</span> float(data[<span class="number">3</span>]) == <span class="number">5.0</span>: <span class="comment"># 选择数字标签是5的列表</span></span><br><span class="line">        x_data.append(float(data[<span class="number">0</span>]))</span><br><span class="line">        y_data.append(float(data[<span class="number">1</span>]))</span><br><span class="line">        c_data.append(float(data[<span class="number">2</span>]))</span><br><span class="line">        l_data.append(float(data[<span class="number">3</span>]))</span><br><span class="line">        <span class="attr">n</span> = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造模型</span></span><br><span class="line"><span class="attr">A</span> = tf.Variable([[<span class="number">0.9454796</span>, <span class="number">1.388481</span>, -<span class="number">0.11770888</span>]])</span><br><span class="line"><span class="attr">B</span> = tf.Variable([[-<span class="number">0.32141185</span>, -<span class="number">0.32455823</span>, <span class="number">9.266867</span>]])</span><br><span class="line"><span class="attr">C</span> = tf.Variable([[<span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="attr">a</span> = tf.Variable([-<span class="number">4.138437</span>])</span><br><span class="line"><span class="attr">b</span> = tf.Variable([<span class="number">0.20216514</span>])</span><br><span class="line"></span><br><span class="line">def gm(x, y, z):</span><br><span class="line">    return tf.matmul(A, [x, y, z]) + a</span><br><span class="line"></span><br><span class="line">def fm(x, y, z):</span><br><span class="line">    <span class="attr">D</span> = tf.concat([gm(tf.square(x),y,z) , gm(x,tf.square(y),z), gm(x,y,tf.square(z))], <span class="number">0</span>)</span><br><span class="line">    return tf.matmul(B, D) + tf.matmul(C, [x, y, z]) + b</span><br><span class="line"></span><br><span class="line"><span class="attr">col</span> = fm(x_data, y_data, l_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小化方差</span></span><br><span class="line"><span class="attr">loss</span> = tf.reduce_mean(tf.square(c_data - col))</span><br><span class="line"><span class="attr">optimizer</span> = tf.train.GradientDescentOptimizer(<span class="number">0.000005</span>)</span><br><span class="line"><span class="attr">train</span> = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化变量</span></span><br><span class="line"><span class="attr">init</span> = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动图 (graph)</span></span><br><span class="line"><span class="attr">sess</span> = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># csv_file = open('run.csv', 'w')</span></span><br><span class="line"><span class="comment"># csv_write = csv.writer(csv_file)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合</span></span><br><span class="line">for step <span class="keyword">in</span> range(<span class="number">1000000001</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="attr">A1</span> = sess.run(A)</span><br><span class="line">        <span class="attr">B1</span> = sess.run(B)</span><br><span class="line">        <span class="attr">C1</span> = sess.run(C)</span><br><span class="line"></span><br><span class="line">        <span class="attr">a1</span> = sess.run(a)</span><br><span class="line">        <span class="attr">b1</span> = sess.run(b)</span><br><span class="line">        <span class="attr">l</span> = sess.run(loss)</span><br><span class="line"></span><br><span class="line">        print(step, A1, B1, C1, a1, b1, l)</span><br><span class="line">        <span class="comment"># csv_write.writerow([step, A1[0][0], A1[0][1], A1[0][2], B1[0][0], B1[0][1], B1[0][2], a1[0], b1[0], l])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#csv_file.close()</span></span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>我的电脑没装独立显卡，CPU也比较烂，再加上学习率很初始值还没优化好，所以训练了一个晚上，loss的值波动在4959左右，我认为至少也要下降到2000以下才会有个可观的效果。  </p><p>目前效果是非常失败的，如下图，第二张图是模型输出的数字5。<br><img src="/images/blog/15.PNG" alt=""><br><img src="/images/blog/16.PNG" alt=""></p><p>我估计从方法上就有很大问题，应该用卷积什么的，所以这个算是彻底失败了，暂时搞不成了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从识别数字开始&quot;&gt;&lt;a href=&quot;#从识别数字开始&quot; class=&quot;headerlink&quot; title=&quot;从识别数字开始&quot;&gt;&lt;/a&gt;从识别数字开始&lt;/h2&gt;&lt;p&gt;MNIST文件中包含了几万个手写数字的灰度图片，这些图片尺寸是28&lt;em&gt; 28，灰度值为[0, 128)，机器学习有两个入门的“Hello World”，除了做散点图的回归直线外，就是识别手写数字，这个过程一般涉及三个神经网络层，输入层（28 &lt;/em&gt;28 = 784个神经元），隐藏层（神经元个数按需决定），输出层（10个神经元，代表10个可能的数字）。所以将模型建好后，训练模型，优化所有的神经元权重和偏移，使得残差平方的平均值loss降到最低。得到的模型后，将含有784个数值的矩阵X（也就是手写的数字图片）输入到模型中，经过一层层神经元，最后映射到一个含有10个数值的矩阵Y（也就是 Y = f(X) ），这个矩阵有10个数值，每个数值代表相应数字的概率。我们选取概率最大的那个，这样就实现了输入一张手写数字图片，输出这张图片上所写的数字。经过百万次训练，这个准确率可以达到95%以上。&lt;br&gt;&lt;img src=&quot;/images/blog/14.PNG&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hk-shao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="https://hk-shao.github.io/tags/TensorFlow/"/>
    
      <category term="机器创造" scheme="https://hk-shao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%88%9B%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>公式F=ma中的力从哪来？</title>
    <link href="https://hk-shao.github.io/2019/02/06/%E5%85%AC%E5%BC%8FF-ma%E4%B8%AD%E7%9A%84%E5%8A%9B%E4%BB%8E%E5%93%AA%E6%9D%A5%EF%BC%9F/"/>
    <id>https://hk-shao.github.io/2019/02/06/公式F-ma中的力从哪来？/</id>
    <published>2019-02-06T04:41:43.000Z</published>
    <updated>2019-02-06T04:58:51.829Z</updated>
    
    <content type="html"><![CDATA[<p>来自《“世界物理年”专稿》，觉得写的很有深度，所以分享出来。</p><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><img src="/images/blog/F=ma/1.PNG" alt=""><a id="more"></a>  </p><p><img src="/images/blog/F=ma/2.PNG" alt="">  </p><p><img src="/images/blog/F=ma/3.PNG" alt="">  </p><p><img src="/images/blog/F=ma/4.PNG" alt="">  </p><p><img src="/images/blog/F=ma/5.PNG" alt="">  </p><p><img src="/images/blog/F=ma/6.PNG" alt="">  </p><p><img src="/images/blog/F=ma/7.PNG" alt="">  </p><p><img src="/images/blog/F=ma/8.PNG" alt="">  </p><p><img src="/images/blog/F=ma/9.PNG" alt="">  </p><p><img src="/images/blog/F=ma/10.PNG" alt="">  </p><h2 id="PDF文件"><a href="#PDF文件" class="headerlink" title="PDF文件"></a>PDF文件</h2><p><a href="/files/公式F=ma中的力从哪来？.pdf">点击这里</a>下载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自《“世界物理年”专稿》，觉得写的很有深度，所以分享出来。&lt;/p&gt;
&lt;h2 id=&quot;原文&quot;&gt;&lt;a href=&quot;#原文&quot; class=&quot;headerlink&quot; title=&quot;原文&quot;&gt;&lt;/a&gt;原文&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/blog/F=ma/1.PNG&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="PDF" scheme="https://hk-shao.github.io/tags/PDF/"/>
    
      <category term="物理" scheme="https://hk-shao.github.io/tags/%E7%89%A9%E7%90%86/"/>
    
      <category term="力学" scheme="https://hk-shao.github.io/tags/%E5%8A%9B%E5%AD%A6/"/>
    
      <category term="转载" scheme="https://hk-shao.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>一个超级赖皮的数学证明方法——例证法</title>
    <link href="https://hk-shao.github.io/2019/02/04/%E4%B8%80%E4%B8%AA%E8%B6%85%E7%BA%A7%E8%B5%96%E7%9A%AE%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E4%BE%8B%E8%AF%81%E6%B3%95/"/>
    <id>https://hk-shao.github.io/2019/02/04/一个超级赖皮的数学证明方法——例证法/</id>
    <published>2019-02-04T04:41:02.000Z</published>
    <updated>2019-02-06T04:43:28.487Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章作者是：physixfan，<a href="https://www.physixfan.com/%E4%B8%80%E4%B8%AA%E8%B6%85%E7%BA%A7%E8%B5%96%E7%9A%AE%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E4%BE%8B%E8%AF%81%E6%B3%95/" target="_blank" rel="noopener">点击这里</a>查看原文  </p><h2 id="原文（有删减）"><a href="#原文（有删减）" class="headerlink" title="原文（有删减）"></a>原文（有删减）</h2><p>今天看到《数学家的眼光》（张景中著）写到了一个巨赖皮的数学证明方法，叫例证法，看完我都惊得不行了，就写到这里来和大家分享一下。<br>为了说明例证法，我们举一个简单的例子。试证明： $(x+1)(x-1)=x^2-1$ 。我们假设我们不会做（这不是在贬低你的智商啊）。现在我就讲一个所有人都肯定能学会的方法，用例证法来证明！</p><blockquote><p>证明：令 $x=1$ 代入原式，发现等式成立。<br>令 $x=2$ 代入原式，发现等式成立。<br>令 $x=3$ 代入原式，发现等式成立。<br>所以原式恒成立。  </p></blockquote><p>你看了可能会狂笑不止，有种想揍我的冲动，这什么东西，举了3个例子就说证明了原式？证明等式成立可必须是所有x都满足才行啊！可是，且慢，我可以告诉你，这样证明是严谨的。不信就听我仔细分析。分析一下原等式，发现x的最高次是2次。根据代数基本定理，这个式子如果不是恒等式就有两个根。现在我们举了3个例子，即便前两个正好就是两个根，那么第三个数代进去又成立了，就说明原式是恒等式了！<a id="more"></a></p><p>怎么样，这个例证法神奇吧！</p><p>我们还可以把它推广，如果有多个未知数，例如想要证明 $(x^2+y)(x^2-y)=x^4-y^2$ ，我们只要把 $x$ 附 $5$ 个值， $y$ 附 $3$ 个值，一共代 $15$ 组数进去验证就可以了。 </p><p>据说，我国一个数学家（笔者注：就是张景中）甚至把例证法推广，利用解析几何把普通几何题转变为类似的代数问题，就可以用例证法来证明了（笔者注：就是机器证明）！</p><p>不知道，如果我在高考的时候用这么个方法，老师会给我几分？呵呵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章作者是：physixfan，&lt;a href=&quot;https://www.physixfan.com/%E4%B8%80%E4%B8%AA%E8%B6%85%E7%BA%A7%E8%B5%96%E7%9A%AE%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E4%BE%8B%E8%AF%81%E6%B3%95/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;查看原文  &lt;/p&gt;
&lt;h2 id=&quot;原文（有删减）&quot;&gt;&lt;a href=&quot;#原文（有删减）&quot; class=&quot;headerlink&quot; title=&quot;原文（有删减）&quot;&gt;&lt;/a&gt;原文（有删减）&lt;/h2&gt;&lt;p&gt;今天看到《数学家的眼光》（张景中著）写到了一个巨赖皮的数学证明方法，叫例证法，看完我都惊得不行了，就写到这里来和大家分享一下。&lt;br&gt;为了说明例证法，我们举一个简单的例子。试证明： $(x+1)(x-1)=x^2-1$ 。我们假设我们不会做（这不是在贬低你的智商啊）。现在我就讲一个所有人都肯定能学会的方法，用例证法来证明！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：令 $x=1$ 代入原式，发现等式成立。&lt;br&gt;令 $x=2$ 代入原式，发现等式成立。&lt;br&gt;令 $x=3$ 代入原式，发现等式成立。&lt;br&gt;所以原式恒成立。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你看了可能会狂笑不止，有种想揍我的冲动，这什么东西，举了3个例子就说证明了原式？证明等式成立可必须是所有x都满足才行啊！可是，且慢，我可以告诉你，这样证明是严谨的。不信就听我仔细分析。分析一下原等式，发现x的最高次是2次。根据代数基本定理，这个式子如果不是恒等式就有两个根。现在我们举了3个例子，即便前两个正好就是两个根，那么第三个数代进去又成立了，就说明原式是恒等式了！
    
    </summary>
    
    
      <category term="数学" scheme="https://hk-shao.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="转载" scheme="https://hk-shao.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="等式" scheme="https://hk-shao.github.io/tags/%E7%AD%89%E5%BC%8F/"/>
    
      <category term="证明" scheme="https://hk-shao.github.io/tags/%E8%AF%81%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>用TensorFlow机器学习框架构建学校学科成绩的线性模型</title>
    <link href="https://hk-shao.github.io/2019/01/31/%E7%94%A8TensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E6%9E%84%E5%BB%BA%E5%AD%A6%E6%A0%A1%E5%AD%A6%E7%A7%91%E6%88%90%E7%BB%A9%E7%9A%84%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hk-shao.github.io/2019/01/31/用TensorFlow机器学习框架构建学校学科成绩的线性模型/</id>
    <published>2019-01-31T09:15:59.000Z</published>
    <updated>2019-02-04T11:53:26.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TensorFlow机器学习框架"><a href="#TensorFlow机器学习框架" class="headerlink" title="TensorFlow机器学习框架"></a>TensorFlow机器学习框架</h2><p>TensorFlow是Google开源的一个机器学习框架，它可以在Python环境下运行，我昨天认识和接触它。<br><img src="/images/blog/10.PNG" alt=""><br><a id="more"></a></p><h2 id="模型构建方法-amp-事情经过"><a href="#模型构建方法-amp-事情经过" class="headerlink" title="模型构建方法&amp;事情经过"></a>模型构建方法&amp;事情经过</h2><p>昨天我用Excel尝试绘制了我们学校高二年级的各个学科——物理散点图，然后用Excel绘制了三次方回归曲线，我发现不论是哪个学科与物理，拟合优度 $R^2$ 都很低，这代表它们之间的的关系并不明显，几乎是随机的。  </p><p>因此我就想，如果一个量映射到另一个量的关系不明显，那我几个量映射到一个量可能就会有比较强的关系了。但是想要找到这个关系，似乎非常困难，我尝试把各个学科与物理的三次方回归曲线以它的拟合优度 $R^2$ 为权重线性混合起来，结果得到了一个不三不四的方程，处理极其困难，误差也很大。  </p><p>刚好昨天认识了TensorFlow（后面简称TF），于是打算下载使用TF训练出我想要的模型，但是在安装TF的过程中遇到了很多坑，这里我就不细说了。  </p><p>在使用TF前，我简单的看了几个别人写的Demo，然后我就开始构建学校学科成绩的线性模型，步骤基本分为下面几个。</p><h3 id="1，构建模型"><a href="#1，构建模型" class="headerlink" title="1，构建模型"></a>1，构建模型</h3><p>我将物理成绩构建成一个线性模型，满足下面这个式子：<br>$$<br>{\begin{aligned}<br>物理成绩 &amp;\approx a \times 语文成绩 \<br>&amp;+ b \times 数学成绩 \<br>&amp;+ c \times 英语成绩 \<br>&amp;+ d \times 化学成绩 \<br>&amp;+ e \times 生物成绩 \<br>&amp;+ s<br>\end{aligned}}<br>$$<br>我们只需要使用TF，把上式的各个系数优化到最贴近真实，使得我把一个真实的成绩代入上式后能得到一个较为精确的值。</p><h3 id="2，找数据，然后把数据转换成csv格式"><a href="#2，找数据，然后把数据转换成csv格式" class="headerlink" title="2，找数据，然后把数据转换成csv格式"></a>2，找数据，然后把数据转换成csv格式</h3><p>我找到了我们高二年级这次期末统考成绩的表格，用Excel打开它，然后提取所需要的数据，另存为csv格式。</p><h3 id="3，用Python写一个读取csv的程序"><a href="#3，用Python写一个读取csv的程序" class="headerlink" title="3，用Python写一个读取csv的程序"></a>3，用Python写一个读取csv的程序</h3><p>要注意csv文件的编码！其它我就不细说了。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">csv_file = csv.reader(<span class="built_in">open</span>(<span class="string">'cj.csv'</span>, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">x_data = []</span><br><span class="line">y_data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data in csv_file:</span><br><span class="line">    x_s = data[<span class="number">3</span>]</span><br><span class="line">    y_s = data[<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">if</span> not len(x_s) * len(y_s) == <span class="number">0</span>:</span><br><span class="line">        x_data.<span class="built_in">append</span>(<span class="built_in">float</span>(x_s))</span><br><span class="line">        y_data.<span class="built_in">append</span>(<span class="built_in">float</span>(y_s))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x_data)</span><br></pre></td></tr></table></figure></p><h3 id="4，用Python写TS的模型训练程序"><a href="#4，用Python写TS的模型训练程序" class="headerlink" title="4，用Python写TS的模型训练程序"></a>4，用Python写TS的模型训练程序</h3><p>运行下面的这个程序，训练一千万次来优化系数。具体不细说了，下面是这个工程的全部源码：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow <span class="keyword">as</span> <span class="keyword">tf</span></span><br><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">import csv</span><br><span class="line"></span><br><span class="line">csv_file = csv.reader(<span class="keyword">open</span>(<span class="string">'cj.csv'</span>, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">a_data = []</span><br><span class="line">b_data = []</span><br><span class="line">c_data = []</span><br><span class="line">d_data = []</span><br><span class="line">e_data = []</span><br><span class="line">y_data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data in csv_file:</span><br><span class="line">    a_s = data[<span class="number">0</span>]</span><br><span class="line">    b_s = data[<span class="number">1</span>]</span><br><span class="line">    c_s = data[<span class="number">2</span>]</span><br><span class="line">    d_s = data[<span class="number">3</span>]</span><br><span class="line">    e_s = data[<span class="number">4</span>]</span><br><span class="line">    y_s = data[<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">if</span> not <span class="built_in">len</span>(a_s)*<span class="built_in">len</span>(b_s)*<span class="built_in">len</span>(c_s)*<span class="built_in">len</span>(d_s)*<span class="built_in">len</span>(e_s)*<span class="built_in">len</span>(y_s) == <span class="number">0</span>:</span><br><span class="line">        a_data.<span class="keyword">append</span>(float(a_s))</span><br><span class="line">        b_data.<span class="keyword">append</span>(float(b_s))</span><br><span class="line">        c_data.<span class="keyword">append</span>(float(c_s))</span><br><span class="line">        d_data.<span class="keyword">append</span>(float(d_s))</span><br><span class="line">        e_data.<span class="keyword">append</span>(float(e_s))</span><br><span class="line">        y_data.<span class="keyword">append</span>(float(y_s))</span><br><span class="line"></span><br><span class="line"># 构造一个线性模型</span><br><span class="line"><span class="keyword">a</span> = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line"><span class="keyword">b</span> = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line"><span class="keyword">c</span> = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">d = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line"><span class="keyword">e</span> = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">s = <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">y</span> = <span class="keyword">a</span>*a_data + <span class="keyword">b</span>*b_data + <span class="keyword">c</span>*c_data + d*d_data + <span class="keyword">e</span>*e_data + s</span><br><span class="line"></span><br><span class="line"># 最小化方差</span><br><span class="line">loss = <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.square(<span class="keyword">y</span> - y_data))</span><br><span class="line">optimizer = <span class="keyword">tf</span>.train.GradientDescentOptimizer(<span class="number">0.00001</span>)</span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"># 初始化变量</span><br><span class="line">init = <span class="keyword">tf</span>.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"># 启动图 (graph)</span><br><span class="line">sess = <span class="keyword">tf</span>.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"># 拟合</span><br><span class="line"><span class="keyword">for</span> step in <span class="built_in">range</span>(<span class="number">10000001</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">1000000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span>(step, sess.run(<span class="keyword">a</span>), sess.run(<span class="keyword">b</span>), sess.run(<span class="keyword">c</span>), sess.run(d), sess.run(<span class="keyword">e</span>), sess.run(s))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> True :</span><br><span class="line">    a1 = float(<span class="built_in">input</span>(<span class="string">"语文成绩："</span>))</span><br><span class="line">    b1 = float(<span class="built_in">input</span>(<span class="string">"数学成绩："</span>))</span><br><span class="line">    c1 = float(<span class="built_in">input</span>(<span class="string">"英语成绩："</span>))</span><br><span class="line">    d1 = float(<span class="built_in">input</span>(<span class="string">"化学成绩："</span>))</span><br><span class="line">    e1 = float(<span class="built_in">input</span>(<span class="string">"生物成绩："</span>))</span><br><span class="line">    v = sess.run(<span class="keyword">a</span>)*a1 + sess.run(<span class="keyword">b</span>)*b1 + sess.run(<span class="keyword">c</span>)*c1 + sess.run(d)*d1 + sess.run(<span class="keyword">e</span>)*e1 + sess.run(s)</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"你的物理成绩大概是："</span>, v[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>$$<br>{\begin{aligned}<br>物理成绩 \approx &amp;-0.04158394 \times 语文成绩 \<br>&amp;+ 0.37960723 \times 数学成绩 \<br>&amp;+ 0.18630792 \times 英语成绩 \<br>&amp;+ 0.48215818 \times 化学成绩 \<br>&amp;+ 0.28883076 \times 生物成绩 \<br>&amp;- 26.1632100<br>\end{aligned}}<br>$$</p><p><img src="/images/blog/11.PNG" alt=""></p><h2 id="猜想和总结"><a href="#猜想和总结" class="headerlink" title="猜想和总结"></a>猜想和总结</h2><p>上面的一个模型，使用范围是有限的，因为我的数据仅仅只是我们学校高二年级在2019年的期末统考数据。精度也是有限的，因为我的数据只有1000多个，并且我使用的是线性模型，所以一般来说误差会在10以内，比较好的情况下误差不超过2。  </p><p>如果把模型构建成二次方，三次方，甚至更多，那么所得到的模型就越贴近真实，但是训练次数也要更多，模型的表达式也会很复杂。</p><p>上面式子每个成绩前面的系数，就是这个学科成绩对物理成绩的影响大小，可以发现化学成绩前的系数最大，这代表着大部分化学成绩优秀的学生，物理成绩也不会太差。我们还可以发现语文成绩前面的系数竟然是负值！这说明，物理成绩较好的学生，语文往往拖他后退。</p><h2 id="两张散点图"><a href="#两张散点图" class="headerlink" title="两张散点图"></a>两张散点图</h2><h3 id="化学——物理"><a href="#化学——物理" class="headerlink" title="化学——物理"></a>化学——物理</h3><p><img src="/images/blog/12.PNG" alt=""></p><h3 id="语文——物理"><a href="#语文——物理" class="headerlink" title="语文——物理"></a>语文——物理</h3><p><img src="/images/blog/13.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TensorFlow机器学习框架&quot;&gt;&lt;a href=&quot;#TensorFlow机器学习框架&quot; class=&quot;headerlink&quot; title=&quot;TensorFlow机器学习框架&quot;&gt;&lt;/a&gt;TensorFlow机器学习框架&lt;/h2&gt;&lt;p&gt;TensorFlow是Google开源的一个机器学习框架，它可以在Python环境下运行，我昨天认识和接触它。&lt;br&gt;&lt;img src=&quot;/images/blog/10.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="程序&amp;算法" scheme="https://hk-shao.github.io/tags/%E7%A8%8B%E5%BA%8F-%E7%AE%97%E6%B3%95/"/>
    
      <category term="人工智能" scheme="https://hk-shao.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://hk-shao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="https://hk-shao.github.io/tags/TensorFlow/"/>
    
      <category term="数学建模" scheme="https://hk-shao.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>本站着色编辑器上线啦！</title>
    <link href="https://hk-shao.github.io/2019/01/29/%E6%9C%AC%E7%AB%99%E7%9D%80%E8%89%B2%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8A%E7%BA%BF%E5%95%A6%EF%BC%81/"/>
    <id>https://hk-shao.github.io/2019/01/29/本站着色编辑器上线啦！/</id>
    <published>2019-01-29T12:43:56.000Z</published>
    <updated>2019-01-29T14:03:54.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是着色器？"><a href="#什么是着色器？" class="headerlink" title="什么是着色器？"></a>什么是着色器？</h2><p>如果你不知道什么是着色器（Shader），你可以先看我之前写的这篇博客： <a href="https://hk-shao.github.io/2018/08/26/OpenGL%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Shader%EF%BC%89%E5%92%8CGLSL%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/">点击这里</a>  </p><p>我写的可能晦涩难懂，这里强烈推荐一本介绍Shader的书，它可以在线免费阅读，非常感谢它的作者和这本书的翻译！<br><a href="https://thebookofshaders.com/00/?lan=ch" target="_blank" rel="noopener">《The Book of Shaders》</a>——<em>by Patricio Gonzalez Vivo &amp; Jen Lowe</em></p><h2 id="ShaderEditor使用地址"><a href="#ShaderEditor使用地址" class="headerlink" title="ShaderEditor使用地址"></a>ShaderEditor使用地址</h2><p><a href="https://hk-shao.github.io/demo/ShaderEditor/">点击这里</a> 打开着色编辑器。当然，你也可以在本站左下角的Demo里打开，界面如下图<br><img src="/images/blog/9.PNG" alt=""><a id="more"></a></p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p>这个是GitHub上的一个开源项目：<a href="https://github.com/patriciogonzalezvivo/glslEditor" target="_blank" rel="noopener">https://github.com/patriciogonzalezvivo/glslEditor</a><br>我只是把它搬进我的博客网站里而已。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="简单的曲线绘制"><a href="#简单的曲线绘制" class="headerlink" title="简单的曲线绘制"></a>简单的曲线绘制</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_ES</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_time;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define ZOOM 20.0</span></span><br><span class="line"><span class="meta">#define LINE_SIZE 2.0</span></span><br><span class="line"><span class="meta">#define GRAD_OFFS vec2(1e-4 * ZOOM, 0.0)</span></span><br><span class="line"><span class="meta">#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) / GRAD_OFFS.x)</span></span><br><span class="line"><span class="meta">#define PLOT(f, c, d, p) d = mix(c(p), d, smoothstep(0.0, (LINE_SIZE / u_resolution.y * ZOOM), abs(f(p) / length(GRAD(f, p)))))</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Func(<span class="type">vec2</span> p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (p.x * p.x + p.y * p.y - <span class="number">9.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> Color(<span class="type">vec2</span> p) &#123; <span class="keyword">return</span> <span class="type">vec3</span>(<span class="number">1.0</span>); &#125;</span><br><span class="line"><span class="type">float</span> Axes(<span class="type">vec2</span> p) &#123; <span class="keyword">return</span> p.x*p.y; &#125;</span><br><span class="line"><span class="type">vec3</span> Ac(<span class="type">vec2</span> p) &#123; <span class="keyword">return</span> <span class="type">vec3</span>(<span class="number">0.2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> uv = ((<span class="built_in">gl_FragCoord</span>.xy - u_resolution / <span class="number">2.0</span>) / u_resolution.xy) * ZOOM;</span><br><span class="line">    <span class="type">vec3</span> col;</span><br><span class="line">    PLOT(Axes, Ac, col, uv);</span><br><span class="line">    PLOT(Func, Color, col, uv);</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(col, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return (p.x * p.x + p.y * p.y - 9.0);</code> 表示绘制曲线 $x^2+y^2=9$ ，这是一个半径为 $3$ 的圆，你可以将它修改成任何你想绘制的初等函数曲线，比如这样 <code>return (pow(p.x, 2.0) + pow(p.y - pow(pow(p.x, 2.0),1.0 / 3.0), 2.0) - 22.0);</code> 。</p><h3 id="曼德博集绘制"><a href="#曼德博集绘制" class="headerlink" title="曼德博集绘制"></a>曼德博集绘制</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef GL_FRAGMENT_PRECISION_HIGH</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">highp</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> u_resolution;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> C,mcol;</span><br><span class="line"><span class="type">bool</span> bColoring=<span class="literal">false</span>;</span><br><span class="line"><span class="meta">#define pi 3.14159265358979</span></span><br><span class="line"><span class="type">float</span> DE(<span class="keyword">in</span> <span class="type">vec3</span> p)&#123;</span><br><span class="line">    <span class="type">float</span> dr=<span class="number">1.0</span>,r=<span class="built_in">length</span>(p);</span><br><span class="line">    <span class="comment">//C=p;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&gt;<span class="number">20.0</span>)<span class="keyword">break</span>;</span><br><span class="line">        dr=dr*<span class="number">2.0</span>*r;</span><br><span class="line">        <span class="type">float</span> psi = <span class="built_in">abs</span>(<span class="built_in">mod</span>(<span class="built_in">atan</span>(p.z,p.y)+pi/<span class="number">8.0</span>,pi/<span class="number">4.0</span>)-pi/<span class="number">8.0</span>);</span><br><span class="line">        p.yz=<span class="type">vec2</span>(<span class="built_in">cos</span>(psi),<span class="built_in">sin</span>(psi))*<span class="built_in">length</span>(p.yz);</span><br><span class="line">        <span class="type">vec3</span> p2=p*p;</span><br><span class="line">        p=<span class="type">vec3</span>(<span class="type">vec2</span>(p2.x-p2.y,<span class="number">2.0</span>*p.x*p.y)*(<span class="number">1.0</span>-p2.z/(p2.x+p2.y+p2.z)),</span><br><span class="line">            <span class="number">2.0</span>*p.z*<span class="built_in">sqrt</span>(p2.x+p2.y))+C;</span><br><span class="line">        r=<span class="built_in">length</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(bColoring &amp;&amp; i==<span class="number">3</span>)mcol=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">log</span>(r)*r/<span class="built_in">max</span>(dr,<span class="number">1.0</span>),<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rnd(<span class="type">vec2</span> c)&#123;<span class="keyword">return</span> <span class="number">0.5</span>;&#125;</span><br><span class="line"><span class="type">float</span> rndStart(<span class="type">vec2</span> fragCoord)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> shadao(<span class="type">vec3</span> ro, <span class="type">vec3</span> rd, <span class="type">float</span> px, <span class="type">vec2</span> fragCoord)&#123;<span class="comment">//pretty much IQ's SoftShadow</span></span><br><span class="line">    <span class="type">float</span> res=<span class="number">1.0</span>,d,t=<span class="number">2.0</span>*px*rndStart(fragCoord);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        d=<span class="built_in">max</span>(px,DE(ro+rd*t)*<span class="number">1.5</span>);</span><br><span class="line">        t+=d;</span><br><span class="line">        res=<span class="built_in">min</span>(res,d/t+t*<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec3</span> Sky(<span class="type">vec3</span> rd)&#123;<span class="comment">//what sky??</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(<span class="number">0.5</span>+<span class="number">0.5</span>*rd.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec3</span> L;</span><br><span class="line"><span class="type">vec3</span> Color(<span class="type">vec3</span> ro, <span class="type">vec3</span> rd, <span class="type">float</span> t, <span class="type">float</span> px, <span class="type">vec3</span> col, <span class="type">bool</span> bFill, <span class="type">vec2</span> fragCoord)&#123;</span><br><span class="line">    ro+=rd*t;</span><br><span class="line">    bColoring=<span class="literal">true</span>;<span class="type">float</span> d=DE(ro);bColoring=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">vec2</span> e=<span class="type">vec2</span>(px*t,<span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> dn=<span class="type">vec3</span>(DE(ro-e.xyy),DE(ro-e.yxy),DE(ro-e.yyx));</span><br><span class="line">    <span class="type">vec3</span> dp=<span class="type">vec3</span>(DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx));</span><br><span class="line">    <span class="type">vec3</span> N=(dp-dn)/(<span class="built_in">length</span>(dp-<span class="type">vec3</span>(d))+<span class="built_in">length</span>(<span class="type">vec3</span>(d)-dn));</span><br><span class="line">    <span class="type">vec3</span> R=<span class="built_in">reflect</span>(rd,N);</span><br><span class="line">    <span class="type">vec3</span> lc=<span class="type">vec3</span>(<span class="number">1.0</span>,<span class="number">0.9</span>,<span class="number">0.8</span>),sc=<span class="built_in">sqrt</span>(<span class="built_in">abs</span>(<span class="built_in">sin</span>(mcol))),rc=Sky(R);</span><br><span class="line">    <span class="type">float</span> sh=<span class="built_in">clamp</span>(shadao(ro,L,px*t,fragCoord)+<span class="number">0.2</span>,<span class="number">0.0</span>,<span class="number">1.0</span>);</span><br><span class="line">    sh=sh*(<span class="number">0.5</span>+<span class="number">0.5</span>*<span class="built_in">dot</span>(N,L))*<span class="built_in">exp</span>(-t*<span class="number">0.125</span>);</span><br><span class="line">    <span class="type">vec3</span> scol=sh*lc*(sc+rc*<span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0.0</span>,<span class="built_in">dot</span>(R,L)),<span class="number">4.0</span>));</span><br><span class="line">    <span class="keyword">if</span>(bFill)d*=<span class="number">0.05</span>;</span><br><span class="line">    col=<span class="built_in">mix</span>(scol,col,<span class="built_in">clamp</span>(d/(px*t),<span class="number">0.0</span>,<span class="number">1.0</span>));</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">mat3</span> lookat(<span class="type">vec3</span> fw)&#123;</span><br><span class="line">    fw=<span class="built_in">normalize</span>(fw);<span class="type">vec3</span> rt=<span class="built_in">normalize</span>(<span class="built_in">cross</span>(fw,<span class="type">vec3</span>(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>)));<span class="keyword">return</span> <span class="type">mat3</span>(rt,<span class="built_in">cross</span>(rt,fw),fw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">float</span> px=<span class="number">0.5</span>/u_resolution.y;</span><br><span class="line">    L=<span class="built_in">normalize</span>(<span class="type">vec3</span>(<span class="number">0.4</span>,<span class="number">0.8</span>,<span class="number">-0.6</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ro = <span class="type">vec3</span>(<span class="type">vec2</span>(<span class="number">-0.180</span>,<span class="number">0.550</span>),<span class="number">3.862</span>);</span><br><span class="line">    <span class="type">vec3</span> rd=lookat(<span class="number">-2.0</span>*ro*pi)*<span class="built_in">normalize</span>(<span class="type">vec3</span>((<span class="number">2.0</span>*<span class="built_in">gl_FragCoord</span>.xy-u_resolution.xy)/u_resolution.y,<span class="number">3.0</span>));</span><br><span class="line"></span><br><span class="line">    C = <span class="type">vec3</span>(<span class="number">-0.8</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> t=DE(ro)*rndStart(<span class="built_in">gl_FragCoord</span>.xy),d=<span class="number">0.0</span>,od=<span class="number">10.0</span>;</span><br><span class="line">    <span class="type">vec3</span> edge=<span class="type">vec3</span>(<span class="number">-1.0</span>);</span><br><span class="line">    <span class="type">bool</span> bGrab=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">vec3</span> col=Sky(rd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">78</span>;i++)&#123;</span><br><span class="line">        t+=d*<span class="number">0.5</span>;</span><br><span class="line">        d=DE(ro+rd*t);</span><br><span class="line">        <span class="keyword">if</span>(d&gt;od)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bGrab &amp;&amp; od&lt;px*t &amp;&amp; edge.x&lt;<span class="number">0.0</span>)&#123;</span><br><span class="line">                edge=<span class="type">vec3</span>(edge.yz,t-od);</span><br><span class="line">                bGrab=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> bGrab=<span class="literal">true</span>;</span><br><span class="line">        od=d;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;<span class="number">5.0</span> || d&lt;<span class="number">1e-5</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> bFill=<span class="literal">false</span>;</span><br><span class="line">    d*=<span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;px*t &amp;&amp; t&lt;<span class="number">10.0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge.x&gt;<span class="number">0.0</span>)edge=edge.zxy;</span><br><span class="line">        edge=<span class="type">vec3</span>(edge.yz,t);</span><br><span class="line">        bFill=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(edge.z&gt;<span class="number">0.0</span>)col=Color(ro,rd,edge.z,px,col,bFill,<span class="built_in">gl_FragCoord</span>.xy);</span><br><span class="line">        edge=edge.zxy;</span><br><span class="line">        bFill=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">2.0</span>*col,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以修改一些参数来绘制更加惊艳的效果。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>运行着色编辑器需要支持WebGL的浏览器</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是着色器？&quot;&gt;&lt;a href=&quot;#什么是着色器？&quot; class=&quot;headerlink&quot; title=&quot;什么是着色器？&quot;&gt;&lt;/a&gt;什么是着色器？&lt;/h2&gt;&lt;p&gt;如果你不知道什么是着色器（Shader），你可以先看我之前写的这篇博客： &lt;a href=&quot;https://hk-shao.github.io/2018/08/26/OpenGL%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Shader%EF%BC%89%E5%92%8CGLSL%E8%AF%AD%E8%A8%80%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/&quot;&gt;点击这里&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;我写的可能晦涩难懂，这里强烈推荐一本介绍Shader的书，它可以在线免费阅读，非常感谢它的作者和这本书的翻译！&lt;br&gt;&lt;a href=&quot;https://thebookofshaders.com/00/?lan=ch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《The Book of Shaders》&lt;/a&gt;——&lt;em&gt;by Patricio Gonzalez Vivo &amp;amp; Jen Lowe&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;ShaderEditor使用地址&quot;&gt;&lt;a href=&quot;#ShaderEditor使用地址&quot; class=&quot;headerlink&quot; title=&quot;ShaderEditor使用地址&quot;&gt;&lt;/a&gt;ShaderEditor使用地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://hk-shao.github.io/demo/ShaderEditor/&quot;&gt;点击这里&lt;/a&gt; 打开着色编辑器。当然，你也可以在本站左下角的Demo里打开，界面如下图&lt;br&gt;&lt;img src=&quot;/images/blog/9.PNG&quot; alt=&quot;&quot;&gt;
    
    </summary>
    
    
      <category term="程序&amp;算法" scheme="https://hk-shao.github.io/tags/%E7%A8%8B%E5%BA%8F-%E7%AE%97%E6%B3%95/"/>
    
      <category term="OpenGL" scheme="https://hk-shao.github.io/tags/OpenGL/"/>
    
      <category term="Blog" scheme="https://hk-shao.github.io/tags/Blog/"/>
    
      <category term="着色器" scheme="https://hk-shao.github.io/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    
      <category term="Shader" scheme="https://hk-shao.github.io/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg转码视频真的好用！（ffmpeg的简单使用方法）</title>
    <link href="https://hk-shao.github.io/2019/01/29/ffmpeg%E8%BD%AC%E7%A0%81%E8%A7%86%E9%A2%91%E7%9C%9F%E7%9A%84%E5%A5%BD%E7%94%A8%EF%BC%81/"/>
    <id>https://hk-shao.github.io/2019/01/29/ffmpeg转码视频真的好用！/</id>
    <published>2019-01-29T04:43:40.000Z</published>
    <updated>2019-01-29T05:26:00.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转码和编辑视频"><a href="#转码和编辑视频" class="headerlink" title="转码和编辑视频"></a>转码和编辑视频</h2><p>今天用Android Studio（后面简称AS）里的模拟器给系统录屏，用来展示OpenGL可视化的东西，打算上传B站，后来发现AS只能保存webm格式和GIF格式的视频，并且文件体积巨大，视频图像也是顺时针旋转的。  </p><p>没办法，只能找个视频编辑器进行转码和编辑，结果发现网上的视频转码工具基本粗制滥造，像Adobe PR这样的视频剪辑软件我也没必要下载，于是找到了ffmpeg（其实很早之前在树莓派上玩Linux的时候用过）。  </p><p>我进入<a href="http://ffmpeg.org/" target="_blank" rel="noopener">ffmpeg官网</a>下载了Win64版本，下载速度很快，下载下来就是一个压缩包，解压后就是工具本体了，不过它没有任何UI界面，在Windows下你只能进入bin目录，然后Shift+鼠标右键打开命令窗口，使用ffmpeg的指令进行操作。如下图，可以看到转码效率很高。</p><p><img src="/images/blog/8.PNG" alt=""><br>下面分析网上搜集的ffmpeg简单用法，可以进行很多基础的视频编辑。<br><a id="more"></a></p><h2 id="ffmpeg的简单用法"><a href="#ffmpeg的简单用法" class="headerlink" title="ffmpeg的简单用法"></a>ffmpeg的简单用法</h2><h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><p>最简单命令如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> out<span class="selector-class">.ogv</span> -vcodec h264 out.mp4</span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> out<span class="selector-class">.ogv</span> -vcodec mpeg4 out.mp4</span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> out<span class="selector-class">.ogv</span> -vcodec libxvid out.mp4</span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> out<span class="selector-class">.mp4</span> -vcodec wmv1 out.wmv</span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> out<span class="selector-class">.mp4</span> -vcodec wmv2 out.wmv</span><br></pre></td></tr></table></figure></p><p>-i 后面是输入文件名。-vcodec 后面是编码格式，h264 最佳，但 Windows 系统默认不安装。如果是要插入 ppt 的视频，选择 wmv1 或 wmv2 基本上万无一失。  </p><p>附加选项：-r 指定帧率，-s 指定分辨率，-b 指定比特率；于此同时可以对声道进行转码，-acodec 指定音频编码，-ab 指定音频比特率，-ac 指定声道数，例如<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> out<span class="selector-class">.ogv</span> -s <span class="number">640</span>x480 -<span class="selector-tag">b</span> <span class="number">500</span>k -vcodec h264 -r <span class="number">29.97</span> -acodec libfaac -ab <span class="number">48</span>k -ac <span class="number">2</span> out.mp4</span><br></pre></td></tr></table></figure></p><h3 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h3><p>用 -ss 和 -t 选项， 从第 30 秒开始，向后截取 10 秒的视频，并保存：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="selector-tag">input</span><span class="selector-class">.wmv</span> -ss <span class="number">00</span>:<span class="number">00</span>:<span class="number">30.0</span> -c copy -t <span class="number">00</span>:<span class="number">00</span>:<span class="number">10.0</span> output.wmv</span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="selector-tag">input</span><span class="selector-class">.wmv</span> -ss <span class="number">30</span> -c copy -t <span class="number">10</span> output.wmv</span><br></pre></td></tr></table></figure></p><p>达成相同效果，也可以用 -ss 和 -to 选项， 从第 30 秒截取到第 40 秒：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="selector-tag">input</span><span class="selector-class">.wmv</span> -ss <span class="number">30</span> -c copy -to <span class="number">40</span> output.wmv</span><br></pre></td></tr></table></figure></p><p>值得注意的是，ffmpeg 为了加速，会使用关键帧技术， 所以有时剪切出来的结果在起止时间上未必准确。 通常来说，把 -ss 选项放在 -i 之前，会使用关键帧技术； 把 -ss 选项放在 -i 之后，则不使用关键帧技术。 如果要使用关键帧技术又要保留时间戳，可以加上 -copyts 选项：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ffmpeg</span> <span class="selector-tag">-ss</span> 00<span class="selector-pseudo">:01</span><span class="selector-pseudo">:00</span> <span class="selector-tag">-i</span> <span class="selector-tag">video</span><span class="selector-class">.mp4</span> <span class="selector-tag">-to</span> 00<span class="selector-pseudo">:02</span><span class="selector-pseudo">:00</span> <span class="selector-tag">-c</span> <span class="selector-tag">copy</span> <span class="selector-tag">-copyts</span> <span class="selector-tag">cut</span><span class="selector-class">.mp4</span></span><br></pre></td></tr></table></figure></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>把两个视频文件合并成一个。  </p><p>简单地使用 concat demuxer，示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat mylist.txt</span><br><span class="line">file <span class="string">'/path/to/file1'</span></span><br><span class="line">file <span class="string">'/path/to/file2'</span></span><br><span class="line">file <span class="string">'/path/to/file3'</span></span><br><span class="line"> </span><br><span class="line">$ ffmpeg -f concat -<span class="selector-tag">i</span> mylist<span class="selector-class">.txt</span> -c copy output</span><br></pre></td></tr></table></figure></p><p>更多时候，由于输入文件的多样性，需要转成中间格式再合成：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> input1<span class="selector-class">.avi</span> -qscale:v <span class="number">1</span> intermediate1.mpg</span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> input2<span class="selector-class">.avi</span> -qscale:v <span class="number">1</span> intermediate2.mpg</span><br><span class="line">cat intermediate1<span class="selector-class">.mpg</span> intermediate2<span class="selector-class">.mpg</span> &gt; intermediate_all.mpg</span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> intermediate_all<span class="selector-class">.mpg</span> -qscale:v <span class="number">2</span> output.avi</span><br></pre></td></tr></table></figure></p><h3 id="调整播放速度"><a href="#调整播放速度" class="headerlink" title="调整播放速度"></a>调整播放速度</h3><p>加速四倍：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> TheOrigin<span class="selector-class">.mp4</span> -vf  <span class="string">"setpts=0.25*PTS"</span> UpTheOrigin.mp4</span><br></pre></td></tr></table></figure></p><p>四倍慢速：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> TheOrigin<span class="selector-class">.mp4</span> -vf <span class="string">"setpts=4*PTS"</span> DownTheOrigin.mp4</span><br></pre></td></tr></table></figure></p><h3 id="帧率设置"><a href="#帧率设置" class="headerlink" title="帧率设置"></a>帧率设置</h3><p>使用-r选项<br>语法是：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="selector-tag">input</span> -r fps output</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="selector-tag">input</span><span class="selector-class">.avi</span> -r <span class="number">30</span> output.mp4</span><br></pre></td></tr></table></figure></p><h3 id="使用fps-filter"><a href="#使用fps-filter" class="headerlink" title="使用fps filter"></a>使用fps filter</h3><p>另一个设置帧率是用fps filter，特别是在filterchains使用时非常有用。<br>例如：修改输入文件的帧率到25<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -v <span class="keyword">clip</span>.mpg -vf fps=fps=<span class="number">25</span> <span class="keyword">clip</span>.webm</span><br></pre></td></tr></table></figure></p><h3 id="比特率设置"><a href="#比特率设置" class="headerlink" title="比特率设置"></a>比特率设置</h3><p>比特率也是一个决定音视频总体质量的参数。他决定每个时间单位处理的bit数。<br>设置比特率：  </p><p>比特率决定处理1s的编码流需要多少bits，设置用-b选项。区分音视频用-b:a和-b:v<br>例如：设置整体1.5Mbit每秒<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> file<span class="selector-class">.avi</span> -<span class="selector-tag">b</span> <span class="number">1.5</span>M file.mp4</span><br><span class="line"></span><br><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="selector-tag">input</span><span class="selector-class">.avi</span> -<span class="selector-tag">b</span>:v <span class="number">1500</span>K output.mp4</span><br></pre></td></tr></table></figure></p><h3 id="CBR设置"><a href="#CBR设置" class="headerlink" title="CBR设置"></a>CBR设置</h3><p>CBR设置一般用作直播流，比如视频会议。为输出设置CBR,有三个参数必须设置为同一个值。<br>bitrate(-b option), minimal rate(-minrate), maximal rate(-maxrate)。maximal rate需要设置-bufsize选项。例如设置CBR为0.5Mbit/s。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="keyword">in</span><span class="selector-class">.avi</span> -<span class="selector-tag">b</span> <span class="number">0.5</span>M -minrate <span class="number">0.5</span>M -maxrate <span class="number">0.5</span>M -bufsize <span class="number">1</span>M output.mkv</span><br></pre></td></tr></table></figure></p><h3 id="设置输出文件的最大size"><a href="#设置输出文件的最大size" class="headerlink" title="设置输出文件的最大size"></a>设置输出文件的最大size</h3><p>用-fs选项。<br>例如设置输出文件的最大的size为10M<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -<span class="selector-tag">i</span> <span class="selector-tag">input</span><span class="selector-class">.avi</span> -fs <span class="number">10</span>MB output.mp4</span><br></pre></td></tr></table></figure></p><h3 id="文件大小计算"><a href="#文件大小计算" class="headerlink" title="文件大小计算"></a>文件大小计算</h3><p>文件的大小是是音视频流大小的和。<br>视频流的大小的方程式是(除以8是由bits到bytes的转换):<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">video_size</span> = video_bitrate * time_in_seconds / <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p>如果音频是解压缩的，计算公式是：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">audio_size</span> = smpaling_rate * bit_depth * channels * time_in_second / <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p>例如：计算10分钟的视频， 1500kbits/s 视频比特率和 128kbits/s的音频比特率，用下面的计算方法：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_size = video_size + audio_size;</span><br><span class="line">file_size = (video_bitrate + audio_bitrate) * time_in_seconds / <span class="number">8</span>;</span><br><span class="line">file_size = (<span class="number">1500</span> kbits/s + <span class="number">128</span>kbits/s) * <span class="number">600</span>s</span><br><span class="line">file_size = <span class="number">1628</span>kbits/s * <span class="number">600</span>s</span><br><span class="line">file_size = <span class="number">976800</span>kb = <span class="number">976800000</span> b / <span class="number">8</span> = <span class="number">122100000</span> B / <span class="number">1024</span> = <span class="number">119238.28125</span>KB</span><br><span class="line">file_size = <span class="number">119238.28125</span> KB / <span class="number">1024</span> = <span class="number">116.443634033203125</span>MB = <span class="number">116.44</span>M</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;转码和编辑视频&quot;&gt;&lt;a href=&quot;#转码和编辑视频&quot; class=&quot;headerlink&quot; title=&quot;转码和编辑视频&quot;&gt;&lt;/a&gt;转码和编辑视频&lt;/h2&gt;&lt;p&gt;今天用Android Studio（后面简称AS）里的模拟器给系统录屏，用来展示OpenGL可视化的东西，打算上传B站，后来发现AS只能保存webm格式和GIF格式的视频，并且文件体积巨大，视频图像也是顺时针旋转的。  &lt;/p&gt;
&lt;p&gt;没办法，只能找个视频编辑器进行转码和编辑，结果发现网上的视频转码工具基本粗制滥造，像Adobe PR这样的视频剪辑软件我也没必要下载，于是找到了ffmpeg（其实很早之前在树莓派上玩Linux的时候用过）。  &lt;/p&gt;
&lt;p&gt;我进入&lt;a href=&quot;http://ffmpeg.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ffmpeg官网&lt;/a&gt;下载了Win64版本，下载速度很快，下载下来就是一个压缩包，解压后就是工具本体了，不过它没有任何UI界面，在Windows下你只能进入bin目录，然后Shift+鼠标右键打开命令窗口，使用ffmpeg的指令进行操作。如下图，可以看到转码效率很高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/8.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;下面分析网上搜集的ffmpeg简单用法，可以进行很多基础的视频编辑。&lt;br&gt;
    
    </summary>
    
    
      <category term="实用工具" scheme="https://hk-shao.github.io/tags/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
      <category term="视频" scheme="https://hk-shao.github.io/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="教程" scheme="https://hk-shao.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="剪辑" scheme="https://hk-shao.github.io/tags/%E5%89%AA%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>对微积分运算推广的猜想</title>
    <link href="https://hk-shao.github.io/2019/01/27/%E5%AF%B9%E5%BE%AE%E7%A7%AF%E5%88%86%E8%BF%90%E7%AE%97%E6%8E%A8%E5%B9%BF%E7%9A%84%E7%8C%9C%E6%83%B3/"/>
    <id>https://hk-shao.github.io/2019/01/27/对微积分运算推广的猜想/</id>
    <published>2019-01-27T13:43:24.000Z</published>
    <updated>2019-02-03T09:48:56.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不自量力"><a href="#不自量力" class="headerlink" title="不自量力"></a>不自量力</h2><p>本人才疏学浅，数学功底不好，微积分也只是了解一点，竟然想研究这样的高深理论？算了，不过是一个猜想而已，这里把它分享给大家，好让大家了解一下。</p><h2 id="解析延拓"><a href="#解析延拓" class="headerlink" title="解析延拓"></a>解析延拓</h2><p>要知道，在百年来数学的不断发展中，数字这个集合越来越大，从自然数，正整数，整数到有理数，实数，复数。这就是延拓，运算使得数字拥有了价值，运算自然也被延拓了。比如在古代，分数这个二元运算的分子与分母只能是正整数 ，而现在，它的定义域被拓展到了复数。再比如，很早之前 $x^a,a^x,\sin(x),\ln(x)$ 等等初等函数的定义域是实数或者正实数，而现在，它们可以被定义在复数域，并且是唯一的，这就是解析延拓。<br><a id="more"></a><br>最经典的是一元运算阶乘， $0!=1,1!=1,n!=n\times(n-1)!$ 这是一个定义在非负整数上的函数，而它可以被推广到实数域甚至复数域。阶乘函数的解析延拓就是 $\Gamma(x)$ ，当 $n$ 为非负整数时，有 $n!=\Gamma(n+1)$ ，$\Gamma(x)$ 也叫作欧拉第二积分，它在高数上有极其重要的应用，它的定义是 $\Gamma(x)=\int_R t^{x-1}e^{-t}dt$ 。</p><h2 id="将求导运算延拓到实数"><a href="#将求导运算延拓到实数" class="headerlink" title="将求导运算延拓到实数"></a>将求导运算延拓到实数</h2><h3 id="先研究最简单的幂函数"><a href="#先研究最简单的幂函数" class="headerlink" title="先研究最简单的幂函数"></a>先研究最简单的幂函数</h3><p>$$<br>f(x)=x^\alpha<br>$$<br>我们对它求 $n$ 阶导数，$n \in \mathbb{N}$<br>$$<br>f^{(1)}(x)=\alpha x^{\alpha-1} \<br>f^{(2)}(x)=\alpha (\alpha-1) x^{\alpha-2} \<br>\dots \<br>f^{(n)}(x)=\alpha (\alpha-1) \dots (\alpha-n+1) x^{\alpha-n} \<br>$$<br>左右乘一个 $(\alpha-n)!$得到<br>$$<br>(\alpha-n)!f^{(n)}(x)=\alpha !x^{\alpha-n}<br>$$</p><p>故有<br>$$<br>f^{(n)}(x)=\frac{\alpha !}{(\alpha-n) !}x^{\alpha-n}<br>$$</p><p>考虑到我们的目的是延拓求导，也就是把 $n$ 的取值从 $n \in \mathbb{N}$ 变成 $n \in \mathbb{R}$，所以我们把 $\alpha!$ 替换成 $\Gamma(\alpha+1)$ 得到<br>$$<br>f^{(n)}(x)=\frac{\Gamma(\alpha+1)}{\Gamma(\alpha-n+1)}x^{\alpha-n}<br>$$</p><p>因为我们并不确定这种变换到底还是不是求导，所以我们定义一个算子 $D^n$ ，使得 $(D^nf)(x)=f^{(n)}(x)$ ，于是有<br>$$<br>(D^n)f(x)=\frac{\Gamma(\alpha+1)}{\Gamma(\alpha-n+1)}x^{\alpha-n}<br>$$</p><p>要知道，数学有个很美丽之处就是连续，现在 $n$ 连续了，我们尝试把 $f(x)=\frac{1}{2}x^2$ 在算子 $D^n,n \in [0,2]$ 的变换下的动画绘制出来，如下图<br><img src="/images/blog/5.gif" alt=""></p><h3 id="对于积分"><a href="#对于积分" class="headerlink" title="对于积分"></a>对于积分</h3><p>我们知道求导和积分实际上是一对逆运算。特别的，如果函数 $f(x)$ 在定义域上连续且可导，那么在其定义域上有<br>$$<br>\int{\frac{df(x)}{dx}}dx=f(x)<br>$$<br>以前面所猜想的幂函数为例子， $f(x)=x^\alpha$ 的 $-1$ 次导数，实际上就是它的积分。如果我们定义算子 $J$ 使得 $(Jf)(x)=\int{f(x)dx}$ ，我们可以得出这样一个特殊结论。<br>若 $f(x) 是幂函数$ ，则有<br>$$<br>(D^nf)(x)=(J^{-n}f)(x)<br>$$<br>我们尝试把 $f(x)=x^3$ 在算子 $D^n,n \in [-5,5]$ 的变换下的动画绘制出来，如下图</p><p><img src="/images/blog/7.gif" alt=""><br>可以看出， $(D^{-1}f)(x)$ 确实是 $f(x)$ 的积分。  </p><h3 id="正弦函数的一个例子"><a href="#正弦函数的一个例子" class="headerlink" title="正弦函数的一个例子"></a>正弦函数的一个例子</h3><p>猜想<br>$$<br>(D^n\sin)(x)=(J^{-n}\sin)(x)=\cos \left (\frac{n\pi}{2} \right)\sin(x)+\sin \left (\frac{n\pi}{2} \right )\cos(x)=\sin \left (x+\frac{n\pi}{2} \right )<br>$$<br>变换的动画如下图</p><p><img src="/images/blog/6.gif" alt=""></p><h2 id="算子的定义"><a href="#算子的定义" class="headerlink" title="算子的定义"></a>算子的定义</h2><p>这个等式参照维基百科  </p><h3 id="n阶求导算子D"><a href="#n阶求导算子D" class="headerlink" title="n阶求导算子D"></a>n阶求导算子D</h3><p>$$<br>{\displaystyle (D^nf)(x)={\frac {1}{\Gamma (1-n )}}{\frac {d}{dx}}\int _{0}^{x}{\frac {f(t)}{(x-t)^{n }}}\,dt}<br>$$</p><h3 id="α重积分算子J"><a href="#α重积分算子J" class="headerlink" title="α重积分算子J"></a>α重积分算子J</h3><p>$$<br>(J^{\alpha }f)(x)={1 \over \Gamma (\alpha )}\int _{0}^{x}(x-t)^{\alpha -1}f(t)\;dt<br>$$</p><h2 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h2><p>维基百科有关于分数阶微积分的详细介绍：<br><a href="https://en.m.wikipedia.org/wiki/Fractional_calculus" target="_blank" rel="noopener">https://en.m.wikipedia.org/wiki/Fractional_calculus</a></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本人只是猜想和整理，不代表以上内容我都完全搞懂了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不自量力&quot;&gt;&lt;a href=&quot;#不自量力&quot; class=&quot;headerlink&quot; title=&quot;不自量力&quot;&gt;&lt;/a&gt;不自量力&lt;/h2&gt;&lt;p&gt;本人才疏学浅，数学功底不好，微积分也只是了解一点，竟然想研究这样的高深理论？算了，不过是一个猜想而已，这里把它分享给大家，好让大家了解一下。&lt;/p&gt;
&lt;h2 id=&quot;解析延拓&quot;&gt;&lt;a href=&quot;#解析延拓&quot; class=&quot;headerlink&quot; title=&quot;解析延拓&quot;&gt;&lt;/a&gt;解析延拓&lt;/h2&gt;&lt;p&gt;要知道，在百年来数学的不断发展中，数字这个集合越来越大，从自然数，正整数，整数到有理数，实数，复数。这就是延拓，运算使得数字拥有了价值，运算自然也被延拓了。比如在古代，分数这个二元运算的分子与分母只能是正整数 ，而现在，它的定义域被拓展到了复数。再比如，很早之前 $x^a,a^x,\sin(x),\ln(x)$ 等等初等函数的定义域是实数或者正实数，而现在，它们可以被定义在复数域，并且是唯一的，这就是解析延拓。&lt;br&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://hk-shao.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="微积分" scheme="https://hk-shao.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
      <category term="猜想" scheme="https://hk-shao.github.io/tags/%E7%8C%9C%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>一张图形象理解高数中的中值定理</title>
    <link href="https://hk-shao.github.io/2019/01/27/%E4%B8%80%E5%BC%A0%E5%9B%BE%E5%BD%A2%E8%B1%A1%E7%90%86%E8%A7%A3%E9%AB%98%E6%95%B0%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
    <id>https://hk-shao.github.io/2019/01/27/一张图形象理解高数中的中值定理/</id>
    <published>2019-01-27T12:09:09.000Z</published>
    <updated>2019-01-27T16:07:33.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h2><p>中值定理在高数的微积分中运用极其广泛。<br><a id="more"></a><br><img src="/images/blog/4.jpg" alt=""></p><p><em>这张图分享自知乎用户<a href="https://www.zhihu.com/people/xilaganlan/activities" target="_blank" rel="noopener">快来签到小助手</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;中值定理&quot;&gt;&lt;a href=&quot;#中值定理&quot; class=&quot;headerlink&quot; title=&quot;中值定理&quot;&gt;&lt;/a&gt;中值定理&lt;/h2&gt;&lt;p&gt;中值定理在高数的微积分中运用极其广泛。&lt;br&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://hk-shao.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="微积分" scheme="https://hk-shao.github.io/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>建立个人Blog和使用LaTeX写文章</title>
    <link href="https://hk-shao.github.io/2019/01/24/%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BAblog%E5%92%8C%E4%BD%BF%E7%94%A8Latex%E5%86%99%E6%96%87%E7%AB%A0/"/>
    <id>https://hk-shao.github.io/2019/01/24/建立个人blog和使用Latex写文章/</id>
    <published>2019-01-24T07:30:11.000Z</published>
    <updated>2019-01-24T13:40:16.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于建站"><a href="#关于建站" class="headerlink" title="关于建站"></a>关于建站</h2><p>感谢开源的世界，这个博客的二级域名和文件存储都靠GitHub，这个博客的引擎靠的是Hexo，而这个博客的主题是开源的NexT，如果没有他们，我不可能搭建起这个博客。<br>GitHub：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>Hexo：<a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io/</a><br>NexT主题：<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a><br>虽然耗了我整整一天时间，但总的来说，这次建站非常轻松，也是多亏了开源世界。<br><a id="more"></a><br><img src="https://raw.githubusercontent.com/HK-SHAO/HK-SHAO.github.io/master/images/blog/2.PNG" alt="">   </p><h2 id="关于-LaTeX"><a href="#关于-LaTeX" class="headerlink" title="关于 LaTeX"></a>关于 LaTeX</h2><p>在博客里写文章，用的是MarkDown和 $\LaTeX$ ， $\LaTeX$ 主要是用于书写数学式子的，说到这个 $\LaTeX$ ，它是全世界非常著名的文字排版系统，尤其是对数学式子的排版，大量学术论文的排版都靠它，理工的大学生应该会用到它来写论文。<br><img src="https://raw.githubusercontent.com/HK-SHAO/HK-SHAO.github.io/master/images/blog/1.PNG" alt=""><br>说个实话吧，在电脑上书写数学式子太累了，可能是我还不熟练吧。<br>以后我的blog都会发布在这个网站上，大家可以收藏，感谢支持！  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;关于建站&quot;&gt;&lt;a href=&quot;#关于建站&quot; class=&quot;headerlink&quot; title=&quot;关于建站&quot;&gt;&lt;/a&gt;关于建站&lt;/h2&gt;&lt;p&gt;感谢开源的世界，这个博客的二级域名和文件存储都靠GitHub，这个博客的引擎靠的是Hexo，而这个博客的主题是开源的NexT，如果没有他们，我不可能搭建起这个博客。&lt;br&gt;GitHub：&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/&lt;/a&gt;&lt;br&gt;Hexo：&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io/&lt;/a&gt;&lt;br&gt;NexT主题：&lt;a href=&quot;https://github.com/theme-next/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/theme-next/hexo-theme-next&lt;/a&gt;&lt;br&gt;虽然耗了我整整一天时间，但总的来说，这次建站非常轻松，也是多亏了开源世界。&lt;br&gt;
    
    </summary>
    
    
      <category term="公告" scheme="https://hk-shao.github.io/tags/%E5%85%AC%E5%91%8A/"/>
    
      <category term="Blog" scheme="https://hk-shao.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的不等式结论</title>
    <link href="https://hk-shao.github.io/2019/01/24/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%BB%93%E8%AE%BA/"/>
    <id>https://hk-shao.github.io/2019/01/24/一个简单的不等式结论/</id>
    <published>2019-01-24T04:02:08.000Z</published>
    <updated>2019-01-24T13:40:16.316Z</updated>
    
    <content type="html"><![CDATA[<p>这个不等式结论是19/1/13写关于圆锥曲线求线段比值最大值时发现的。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>设 $m,n,a,b&gt;0$ </p><p>若 $x&gt;y$ 则<br>$$<br>\frac{ma^2+nb^2+xab}{ma^2+nb^2+yab} \leqslant \frac{2\sqrt{mn}+x}{2\sqrt{mn}+y}<br>$$</p><p>若 $x&lt;y$ 则<br>$$<br>\frac{ma^2+nb^2+xab}{ma^2+nb^2+yab} \geqslant \frac{2\sqrt{mn}+x}{2\sqrt{mn}+y}<br>$$<br><a id="more"></a></p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>$$<br>\frac{ma^2+nb^2+xab}{ma^2+nb^2+yab} = 1+\frac{x-y}{\frac{ma}{b}+\frac{nb}{a}+y}<br>$$<br>然后分类讨论 $x$ 与 $y$ 的大小关系，利用基本不等式可以得到以上结论。  </p><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>若实数 $x,y$ 满足 $4x^2-5xy+4y^2=5$ ，则 $x^2+y^2$ 的最大值为多少？</p><p>由以上结论可得<br>$$<br>\frac{4x^2+4y^2}{4x^2+4y^2-5xy} \leqslant \frac{2\sqrt{4 \times 4}+0}{2\sqrt{4 \times 4}-5} = \frac{8}{3}<br>$$<br>即<br>$$<br>\frac{4(x^2+y^2)}{5} \leqslant \frac{8}{3}<br>$$<br>故<br>$$<br>x^2+y^2 \leqslant \frac{10}{3}<br>$$</p><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>若实数 $x,y$ 满足 $x^2+y^2+xy=1$ ，则 $x+y$ 的最大值为多少？  </p><p>由以上结论可得<br>$$<br>x+y \leqslant  \sqrt{x^2+y^2+2xy} = \sqrt{\frac{x^2+y^2+2xy}{x^2+y^2+xy}} \leqslant \sqrt{\frac{2+2}{2+1}}=\frac{2\sqrt{3}}{3}<br>$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个不等式结论是19/1/13写关于圆锥曲线求线段比值最大值时发现的。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h2&gt;&lt;p&gt;设 $m,n,a,b&amp;gt;0$ &lt;/p&gt;
&lt;p&gt;若 $x&amp;gt;y$ 则&lt;br&gt;$$&lt;br&gt;\frac{ma^2+nb^2+xab}{ma^2+nb^2+yab} \leqslant \frac{2\sqrt{mn}+x}{2\sqrt{mn}+y}&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;若 $x&amp;lt;y$ 则&lt;br&gt;$$&lt;br&gt;\frac{ma^2+nb^2+xab}{ma^2+nb^2+yab} \geqslant \frac{2\sqrt{mn}+x}{2\sqrt{mn}+y}&lt;br&gt;$$&lt;br&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://hk-shao.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="不等式" scheme="https://hk-shao.github.io/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    
  </entry>
  
</feed>
